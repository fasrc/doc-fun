{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"doc-generator","text":"<p>AI-powered documentation generator with extensible plugin architecture</p> <p> </p>"},{"location":"#what-is-doc-generator","title":"\ud83d\ude80 What is doc-generator?","text":"<p>doc-generator is a sophisticated Python package that automates the creation of high-quality technical documentation using OpenAI's GPT models. Originally designed for Faculty Arts and Sciences Research Computing (FASRC), it transforms simple topic descriptions into comprehensive, structured documentation with intelligent recommendations.</p> <p>Quick Example</p> <pre><code># Generate comprehensive documentation in seconds\ndoc-gen --topic \"Python Machine Learning with GPU\" --output-dir ./docs\n\n# Result: Professional HTML documentation with:\n# \u2705 HPC module recommendations (python/3.12.8, cuda/12.9.1)\n# \u2705 Installation instructions\n# \u2705 Code examples and workflows\n# \u2705 Best practices and troubleshooting\n</code></pre>"},{"location":"#key-features","title":"\u2728 Key Features","text":""},{"location":"#ai-powered-generation","title":"\ud83e\udde0 AI-Powered Generation","text":"<ul> <li>OpenAI GPT Integration with customizable models (GPT-4, GPT-4o-mini) and parameters</li> <li>Few-shot Prompting with curated examples for consistent, high-quality output</li> <li>Parameterized Templates with runtime customization for different organizations</li> <li>Multiple Format Support including HTML, Markdown, and custom formats</li> </ul>"},{"location":"#extensible-plugin-architecture","title":"\ud83d\udd0c Extensible Plugin Architecture","text":"<ul> <li>Built-in ModuleRecommender suggests relevant HPC modules automatically</li> <li>Third-party Plugin Support via Python entry points for unlimited extensibility</li> <li>Priority-based Ordering and intelligent plugin management</li> <li>Community Ecosystem ready for datasets, workflows, code templates, and more</li> </ul>"},{"location":"#quality-assurance-pipeline","title":"\ud83d\udcca Quality Assurance Pipeline","text":"<ul> <li>Multi-run Generation with temperature variation for optimal results</li> <li>Algorithmic Analysis with section scoring and structure validation</li> <li>GPT-based Quality Evaluation for technical accuracy assessment</li> <li>Best-variant Compilation automatically selects optimal content</li> </ul>"},{"location":"#professional-development-tools","title":"\ud83d\udee0\ufe0f Professional Development Tools","text":"<ul> <li>Comprehensive CLI with 15+ command-line options</li> <li>Python API for programmatic integration</li> <li>Code Scanning for automatic example discovery</li> <li>Batch Processing capabilities for documentation sets</li> </ul>"},{"location":"#perfect-for","title":"\ud83c\udfaf Perfect For","text":"<ul> <li> <p> Research Computing</p> <p>Generate HPC user guides, software documentation, and cluster tutorials with intelligent module recommendations.</p> </li> <li> <p> Software Development</p> <p>Create API documentation, installation guides, and user manuals with automatic code example discovery.</p> </li> <li> <p> DevOps &amp; Infrastructure</p> <p>Build deployment guides, configuration documentation, and troubleshooting resources.</p> </li> <li> <p> Academic Documentation</p> <p>Produce research methodology docs, software tutorials, and reproducible workflow guides.</p> </li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"Development InstallProduction Install <pre><code># Clone and install for development\ngit clone https://github.com/fasrc/doc-fun.git\ncd doc-fun\npip install -e \".[dev]\"\n\n# Verify installation\ndoc-gen --version\ndoc-gen --list-plugins\n</code></pre> <pre><code># Install from PyPI (coming soon)\npip install doc-generator\n\n# Set up environment\necho \"OPENAI_API_KEY=your-key\" &gt; .env\n</code></pre>"},{"location":"#your-first-documentation","title":"Your First Documentation","text":"<pre><code># 1. Set your OpenAI API key\nexport OPENAI_API_KEY=\"your-api-key-here\"\n\n# 2. Generate documentation\ndoc-gen --topic \"Python Data Analysis with Pandas\" --output-dir ./my-docs\n\n# 3. View the results\nopen my-docs/python_data_analysis_with_pandas_gpt4omini_temp03.html\n</code></pre> <p>What You Get</p> <p>Your generated documentation will include:</p> <ul> <li>Intelligent Module Recommendations: <code>module load python/3.12.8-fasrc01</code>, <code>module load gcc/12.2.0-fasrc01</code></li> <li>Structured Content: Description, Installation, Usage, Examples, References</li> <li>Professional Formatting: Clean HTML with syntax highlighting</li> <li>Context-Aware Suggestions: HPC-specific commands and best practices</li> </ul>"},{"location":"#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":""},{"location":"#plugin-system","title":"Plugin System","text":"<p>The heart of doc-generator is its extensible plugin architecture:</p> <pre><code>graph TB\n    A[DocumentationGenerator] --&gt; B[PluginManager]\n    B --&gt; C[ModuleRecommender]\n    B --&gt; D[DatasetRecommender]\n    B --&gt; E[WorkflowRecommender]\n    B --&gt; F[CustomPlugin]\n\n    C --&gt; G[HPC Modules]\n    D --&gt; H[Research Data]\n    E --&gt; I[SLURM Scripts]\n    F --&gt; J[Your Content]\n\n    G --&gt; K[Generated Documentation]\n    H --&gt; K\n    I --&gt; K\n    J --&gt; K</code></pre>"},{"location":"#package-structure","title":"Package Structure","text":"<pre><code>src/doc_generator/\n\u251c\u2500\u2500 __init__.py              # Package exports  \n\u251c\u2500\u2500 core.py                  # DocumentationGenerator class\n\u251c\u2500\u2500 cli.py                   # Command-line interface\n\u251c\u2500\u2500 plugin_manager.py        # Plugin discovery &amp; management\n\u2514\u2500\u2500 plugins/\n    \u251c\u2500\u2500 base.py             # RecommendationEngine interface\n    \u2514\u2500\u2500 modules.py          # Built-in ModuleRecommender\n</code></pre>"},{"location":"#plugin-ecosystem","title":"\ud83d\udd0c Plugin Ecosystem","text":""},{"location":"#built-in-plugins","title":"Built-in Plugins","text":"Plugin Purpose Status ModuleRecommender HPC module suggestions \u2705 Available DatasetRecommender Research dataset discovery \ud83d\udea7 Community WorkflowRecommender SLURM job templates \ud83d\udea7 Community CodeTemplateRecommender Boilerplate code \ud83d\udea7 Community"},{"location":"#create-your-own-plugin","title":"Create Your Own Plugin","text":"<pre><code>from doc_generator.plugins import RecommendationEngine\n\nclass MyAwesomePlugin(RecommendationEngine):\n    def get_name(self) -&gt; str:\n        return \"awesome\"\n\n    def get_recommendations(self, topic: str, context=None):\n        # Your recommendation logic here\n        return [{\n            \"title\": \"Awesome Suggestion\",\n            \"description\": \"This will help with \" + topic,\n            \"relevance_score\": 9.5\n        }]\n</code></pre> <p>Plugin Development</p> <p>Check out our comprehensive Creating Plugins Guide for step-by-step instructions, complete examples, and best practices.</p>"},{"location":"#quality-testing","title":"\ud83d\udcca Quality &amp; Testing","text":""},{"location":"#test-coverage","title":"Test Coverage","text":"<ul> <li>57 comprehensive tests covering all functionality</li> <li>Plugin system integration tests</li> <li>Error handling validation for robustness</li> <li>Mock systems for external dependencies</li> </ul>"},{"location":"#quality-pipeline","title":"Quality Pipeline","text":"<ul> <li>Multi-run generation with temperature variation</li> <li>Algorithmic scoring of structure and content</li> <li>GPT-based evaluation for technical accuracy</li> <li>Best compilation selection</li> </ul> <pre><code># Run the full test suite\npython -m pytest -v\n\n# Generate with quality analysis\ndoc-gen --topic \"Critical Documentation\" --runs 3 --analyze --quality-eval\n</code></pre>"},{"location":"#learning-path","title":"\ud83c\udf93 Learning Path","text":"<ul> <li> <p> Installation Guide</p> <p>Set up doc-generator with all dependencies, virtual environments, and configuration.</p> </li> <li> <p> Getting Started</p> <p>Learn basic usage, command-line options, and your first documentation generation.</p> </li> <li> <p> Testing Guide</p> <p>Understand the test suite, run tests, and write new test cases.</p> </li> <li> <p> Creating Plugins</p> <p>Build custom recommendation engines and extend doc-generator's capabilities.</p> </li> </ul>"},{"location":"#community-support","title":"\ud83e\udd1d Community &amp; Support","text":""},{"location":"#get-involved","title":"Get Involved","text":"<ul> <li>GitHub Repository - Source code and issue tracking</li> <li>Bug Reports - Report issues and request features  </li> <li>FASRC Research Computing - Original development team</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/amazing-plugin</code></li> <li>Run tests: <code>python -m pytest -v</code></li> <li>Submit a pull request</li> </ol>"},{"location":"#success-stories","title":"\ud83d\udcc8 Success Stories","text":"<p>Research Computing Team</p> <p>\"doc-generator transformed how we create user documentation. What used to take hours now takes minutes, and the quality is consistently professional.\"</p> <p>Software Developer</p> <p>\"The plugin architecture is brilliant. I created a custom dataset recommender in 30 minutes that saves our team hours every week.\"</p> <p>Academic Researcher</p> <p>\"Finally, documentation that includes the exact module commands I need. No more digging through wikis and forums.\"</p>"},{"location":"#whats-next","title":"\ud83d\udd2e What's Next?","text":""},{"location":"#upcoming-features","title":"Upcoming Features","text":"<ul> <li>Caching System for faster repeated generations</li> <li>WordPress Integration for direct publishing</li> <li>Batch Processing UI for documentation sets</li> <li>Quality Optimization with A/B testing</li> <li>Community Plugin Registry for easy discovery</li> </ul>"},{"location":"#version-roadmap","title":"Version Roadmap","text":"v1.1.0 (Current)v1.2.0 (Planned)v2.0.0 (Future) <ul> <li>\u2705 Plugin architecture</li> <li>\u2705 CLI interface  </li> <li>\u2705 Enhanced testing (57 tests)</li> <li>\u2705 Professional packaging</li> </ul> <ul> <li>\ud83d\udea7 Caching system</li> <li>\ud83d\udea7 WordPress integration</li> <li>\ud83d\udea7 UI improvements</li> <li>\ud83d\udea7 Additional plugins</li> </ul> <ul> <li>\ud83d\udd2e Multi-model support</li> <li>\ud83d\udd2e Real-time collaboration</li> <li>\ud83d\udd2e Advanced analytics</li> <li>\ud83d\udd2e Enterprise features</li> </ul> <p>Ready to transform your documentation workflow? </p> <p>Get Started Now View on GitHub</p> <p>Built with \u2764\ufe0f by FASRC Research Computing</p>"},{"location":"quality-optimization-approaches/","title":"Quality Optimization Approaches (5b)","text":"<p>This document outlines top-level approaches for implementing A/B testing and quality monitoring in the documentation generation system.</p>"},{"location":"quality-optimization-approaches/#option-a-integrated-experimentation-platform","title":"Option A: Integrated Experimentation Platform","text":"<p>Architecture: Built into DocumentationGenerator with experiment management</p>"},{"location":"quality-optimization-approaches/#components","title":"Components:","text":"<ul> <li>Prompt Variants: Store multiple prompt templates per topic/format</li> <li>Random Assignment: Each generation request gets assigned to variant (with user/session tracking)</li> <li>Quality Collection: Both algorithmic scores and GPT evaluations collected per variant</li> <li>Statistical Engine: Built-in significance testing (t-tests, confidence intervals)</li> <li>Auto-Promotion: Winning variants automatically become default after significance threshold</li> </ul>"},{"location":"quality-optimization-approaches/#pros","title":"Pros:","text":"<ul> <li>Full control over experimentation logic</li> <li>Direct integration with existing quality evaluation pipeline</li> <li>No external dependencies</li> </ul>"},{"location":"quality-optimization-approaches/#cons","title":"Cons:","text":"<ul> <li>Requires building statistical analysis capabilities</li> <li>Higher development complexity</li> <li>Limited scalability for complex experiments</li> </ul>"},{"location":"quality-optimization-approaches/#option-b-external-ab-testing-service","title":"Option B: External A/B Testing Service","text":"<p>Architecture: Integration with services like LaunchDarkly, Optimizely, or custom feature flags</p>"},{"location":"quality-optimization-approaches/#components_1","title":"Components:","text":"<ul> <li>Feature Flags: Control which prompt variant each user/request receives</li> <li>Metrics Pipeline: Quality scores sent to external analytics platform</li> <li>Dashboard: External reporting and experiment management</li> <li>Gradual Rollout: Percentage-based traffic allocation with safety controls</li> </ul>"},{"location":"quality-optimization-approaches/#pros_1","title":"Pros:","text":"<ul> <li>Mature statistical analysis and dashboards</li> <li>Professional experiment management capabilities</li> <li>Built-in safety mechanisms and rollback features</li> </ul>"},{"location":"quality-optimization-approaches/#cons_1","title":"Cons:","text":"<ul> <li>External service dependency and costs</li> <li>Data privacy considerations</li> <li>Limited customization for domain-specific metrics</li> </ul>"},{"location":"quality-optimization-approaches/#option-c-git-based-experimentation","title":"Option C: Git-Based Experimentation","text":"<p>Architecture: Version control for prompt experiments with automated testing</p>"},{"location":"quality-optimization-approaches/#components_2","title":"Components:","text":"<ul> <li>Branch Strategy: Each prompt variant lives in separate git branch</li> <li>CI/CD Testing: Automated quality benchmarks run on pull requests</li> <li>Performance Comparison: Quality metrics compared against baseline branch</li> <li>Merge Strategy: Data-driven merging based on quality improvements</li> </ul>"},{"location":"quality-optimization-approaches/#pros_2","title":"Pros:","text":"<ul> <li>Leverages existing git workflow</li> <li>Clear audit trail and rollback capabilities</li> <li>No additional infrastructure required</li> </ul>"},{"location":"quality-optimization-approaches/#cons_2","title":"Cons:","text":"<ul> <li>Manual experiment management</li> <li>Limited statistical analysis capabilities</li> <li>Slower iteration cycles</li> </ul>"},{"location":"quality-optimization-approaches/#option-d-queue-based-batch-testing","title":"Option D: Queue-Based Batch Testing","text":"<p>Architecture: Offline experimentation with batch processing</p>"},{"location":"quality-optimization-approaches/#components_3","title":"Components:","text":"<ul> <li>Variant Queue: Generate multiple versions of same topic with different prompts</li> <li>Batch Evaluation: Run quality assessments on all variants simultaneously</li> <li>Champion/Challenger: Compare new prompts against current best performer</li> <li>Scheduled Updates: Regular revaluation and prompt optimization cycles</li> </ul>"},{"location":"quality-optimization-approaches/#pros_3","title":"Pros:","text":"<ul> <li>Cost-effective (batch processing)</li> <li>Comprehensive evaluation of variants</li> <li>No impact on live generation performance</li> </ul>"},{"location":"quality-optimization-approaches/#cons_3","title":"Cons:","text":"<ul> <li>Slower feedback cycles</li> <li>Less dynamic adaptation to changing patterns</li> <li>Requires significant computational resources for batch runs</li> </ul>"},{"location":"quality-optimization-approaches/#quality-monitoring-components-common-across-options","title":"Quality Monitoring Components (Common Across Options)","text":""},{"location":"quality-optimization-approaches/#regression-detection","title":"Regression Detection:","text":"<ul> <li>Baseline Thresholds: Quality thresholds per topic category stored in database</li> <li>Moving Averages: Quality metrics tracked over time with anomaly detection algorithms</li> <li>Alert Triggers: Automated notifications when quality drops &gt;X% from baseline</li> </ul>"},{"location":"quality-optimization-approaches/#trend-analysis","title":"Trend Analysis:","text":"<ul> <li>Time-Series Storage: Historical quality metrics in time-series database (InfluxDB/Prometheus)</li> <li>Seasonal Patterns: Recognition of cyclical quality variations (weekday vs weekend, etc.)</li> <li>Content Drift Detection: Identification of topics becoming stale or outdated</li> </ul>"},{"location":"quality-optimization-approaches/#implementation-considerations","title":"Implementation Considerations:","text":"<ul> <li>Metrics Storage: PostgreSQL for structured data + InfluxDB for time-series metrics</li> <li>Alert System: Integration with Slack/email for quality degradation notifications</li> <li>Dashboard: Grafana or custom dashboard for quality trend visualization</li> <li>API Integration: RESTful endpoints for external quality monitoring tools</li> </ul>"},{"location":"quality-optimization-approaches/#recommended-starting-point","title":"Recommended Starting Point","text":"<p>Phase 1: Start with Option D (Queue-Based Batch Testing) for initial implementation - Lower complexity, immediate value - Builds foundation for quality evaluation infrastructure</p> <p>Phase 2: Evolve to Option A (Integrated Platform) as requirements mature - Adds real-time experimentation capabilities - Leverages existing quality evaluation pipeline</p> <p>This approach provides a clear progression path while delivering immediate value through systematic quality optimization.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section provides comprehensive API documentation for doc-generator, automatically generated from source code docstrings.</p>"},{"location":"api/#overview","title":"\ud83d\udccb Overview","text":"<p>The doc-generator API is organized into these main modules:</p> <ul> <li>Core - Main documentation generation classes</li> <li>Plugins - Plugin system and base classes</li> <li>CLI - Command-line interface</li> </ul>"},{"location":"api/#quick-reference","title":"\ud83c\udfaf Quick Reference","text":""},{"location":"api/#main-classes","title":"Main Classes","text":"Class Module Purpose <code>DocumentationGenerator</code> <code>doc_generator.core</code> Main API for generating documentation <code>DocumentAnalyzer</code> <code>doc_generator.core</code> Analyze and score generated documentation <code>GPTQualityEvaluator</code> <code>doc_generator.core</code> GPT-based quality evaluation <code>PluginManager</code> <code>doc_generator.plugin_manager</code> Manage and execute plugins <code>RecommendationEngine</code> <code>doc_generator.plugins.base</code> Base class for all plugins"},{"location":"api/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"api/#basic-generation","title":"Basic Generation","text":"<pre><code>from doc_generator import DocumentationGenerator\n\ngenerator = DocumentationGenerator()\nresults = generator.generate_documentation(\"Python Programming\")\n</code></pre>"},{"location":"api/#with-custom-configuration","title":"With Custom Configuration","text":"<pre><code>generator = DocumentationGenerator(\n    prompt_yaml_path=\"./prompts/custom.yaml\",\n    terminology_path=\"./my-terminology.yaml\"\n)\n</code></pre>"},{"location":"api/#plugin-system","title":"Plugin System","text":"<pre><code>from doc_generator import PluginManager\n\nplugin_manager = PluginManager()\nrecommendations = plugin_manager.get_recommendations(\"Machine Learning\")\n</code></pre>"},{"location":"api/#navigation","title":"\ud83d\udd17 Navigation","text":"<p>Choose a section to explore detailed API documentation:</p> <ul> <li> <p>Core API</p> <p>Main documentation generation classes including <code>DocumentationGenerator</code>, <code>DocumentAnalyzer</code>, and quality evaluation tools.</p> </li> <li> <p>Plugin System</p> <p>Plugin architecture with <code>PluginManager</code>, <code>RecommendationEngine</code> base class, and built-in plugins like <code>ModuleRecommender</code>.</p> </li> <li> <p>CLI Interface</p> <p>Command-line interface implementation with argument parsing, configuration management, and execution logic.</p> </li> </ul>"},{"location":"api/#examples","title":"\ud83d\udca1 Examples","text":""},{"location":"api/#advanced-generation-with-analysis","title":"Advanced Generation with Analysis","text":"<pre><code>from doc_generator import DocumentationGenerator, DocumentAnalyzer\n\n# Initialize components\ngenerator = DocumentationGenerator()\nanalyzer = DocumentAnalyzer()\n\n# Generate multiple variants\nresults = generator.generate_documentation(\n    query=\"Parallel Computing with MPI\",\n    runs=3,\n    model=\"gpt-4\",\n    temperature=0.3\n)\n\n# Analyze each variant\nfor result in results:\n    scores = analyzer.analyze_document(result['content'])\n    print(f\"Quality score: {scores['overall_score']}\")\n</code></pre>"},{"location":"api/#plugin-development","title":"Plugin Development","text":"<pre><code>from doc_generator.plugins import RecommendationEngine\n\nclass CustomRecommender(RecommendationEngine):\n    def get_name(self) -&gt; str:\n        return \"custom\"\n\n    def get_recommendations(self, topic: str, context=None):\n        # Your recommendation logic\n        return [{\"title\": \"Custom Suggestion\", \"score\": 8.5}]\n</code></pre>"},{"location":"api/#related-documentation","title":"\ud83d\udcd6 Related Documentation","text":"<ul> <li>Getting Started Guide - Learn basic usage</li> <li>Creating Plugins Guide - Build custom plugins</li> <li>Configuration Guide - Customize behavior</li> <li>Testing Guide - Test your code</li> </ul> <p>API documentation is automatically generated from source code docstrings using mkdocstrings.</p>"},{"location":"api/cli/","title":"CLI API","text":"<p>The command-line interface provides comprehensive access to all doc-generator features.</p>"},{"location":"api/cli/#cli-module","title":"CLI Module","text":""},{"location":"api/cli/#doc_generator.cli","title":"<code>doc_generator.cli</code>","text":"<p>Command-line interface for doc_generator package.</p>"},{"location":"api/cli/#doc_generator.cli-classes","title":"Classes","text":""},{"location":"api/cli/#doc_generator.cli-functions","title":"Functions","text":""},{"location":"api/cli/#doc_generator.cli.list_plugins","title":"<code>list_plugins(generator)</code>","text":"<p>List all available plugins.</p> Source code in <code>src/doc_generator/cli.py</code> <pre><code>def list_plugins(generator: DocumentationGenerator) -&gt; None:\n    \"\"\"List all available plugins.\"\"\"\n    print(\"Available Recommendation Engine Plugins:\")\n    print(\"=\" * 50)\n\n    engines = generator.plugin_manager.list_engines()\n\n    if not engines:\n        print(\"No plugins loaded.\")\n        return\n\n    for engine in engines:\n        print(f\"\\nPlugin: {engine['name']}\")\n        print(f\"  Class: {engine['class']}\")\n        print(f\"  Module: {engine['module']}\")\n        print(f\"  Supported Types: {', '.join(engine['supported_types'])}\")\n        print(f\"  Priority: {engine['priority']}\")\n        print(f\"  Enabled: {engine['enabled']}\")\n</code></pre>"},{"location":"api/cli/#doc_generator.cli.main","title":"<code>main()</code>","text":"<p>Main entry point for the CLI.</p> Source code in <code>src/doc_generator/cli.py</code> <pre><code>def main():\n    \"\"\"Main entry point for the CLI.\"\"\"\n    args = parse_args()\n\n    # Set up logging\n    logger = setup_logging(args.verbose)\n\n    try:\n        # Handle code scanning mode\n        if args.scan_code:\n            scan_code_examples(args, logger)\n            return\n\n        # Run main generation\n        run_generation(args, logger)\n\n    except KeyboardInterrupt:\n        logger.info(\"Operation cancelled by user\")\n        sys.exit(1)\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        if args.verbose:\n            import traceback\n            traceback.print_exc()\n        sys.exit(1)\n</code></pre>"},{"location":"api/cli/#doc_generator.cli.parse_args","title":"<code>parse_args()</code>","text":"<p>Parse command line arguments.</p> Source code in <code>src/doc_generator/cli.py</code> <pre><code>def parse_args():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(\n        description='Generate technical documentation using AI with plugin-based recommendations',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Basic usage\n  doc-gen --topic \"Python Programming\" --output-dir ./output\n\n  # Multiple runs with custom model\n  doc-gen --topic \"Machine Learning\" --runs 3 --model gpt-4 --temperature 0.7\n\n  # Use custom prompt template\n  doc-gen --topic \"CUDA Programming\" --prompt-yaml ./prompts/cuda.yaml\n\n  # Full analysis pipeline\n  doc-gen --topic \"Parallel Computing\" --runs 5 --analyze --quality-eval\n        \"\"\"\n    )\n\n    # Required arguments\n    parser.add_argument('--topic', \n                       help='Topic to generate documentation for')\n\n    # File path arguments\n    parser.add_argument('--output-dir', default='output',\n                       help='Output directory for generated files (default: output)')\n    parser.add_argument('--prompt-yaml-path', '--prompt-yaml', \n                       default='./prompts/generator/default.yaml',\n                       help='Path to prompt YAML configuration (default: ./prompts/generator/default.yaml)')\n    parser.add_argument('--examples-dir', default='examples',\n                       help='Directory containing few-shot examples (default: examples)')\n    parser.add_argument('--terminology-path', default='terminology.yaml',\n                       help='Path to terminology YAML file (default: terminology.yaml)')\n\n    # Generation parameters\n    parser.add_argument('--runs', type=int, default=1,\n                       help='Number of documentation variants to generate (default: 1)')\n    parser.add_argument('--model', default='gpt-4o-mini',\n                       help='OpenAI model to use (default: gpt-4o-mini)')\n    parser.add_argument('--temperature', type=float, default=0.3,\n                       help='Temperature for text generation (default: 0.3)')\n\n    # Analysis options\n    parser.add_argument('--analyze', action='store_true',\n                       help='Run document analysis after generation')\n    parser.add_argument('--quality-eval', action='store_true',\n                       help='Run GPT-based quality evaluation')\n    parser.add_argument('--analysis-prompt-path', \n                       default='./prompts/analysis/default.yaml',\n                       help='Path to analysis prompt configuration')\n\n    # Plugin options\n    parser.add_argument('--list-plugins', action='store_true',\n                       help='List all available plugins and exit')\n    parser.add_argument('--disable-plugins', nargs='*', metavar='PLUGIN',\n                       help='Disable specific plugins by name')\n    parser.add_argument('--enable-only', nargs='*', metavar='PLUGIN',\n                       help='Enable only specified plugins (disable all others)')\n\n    # Code scanning options\n    parser.add_argument('--scan-code', nargs='?', const='.', metavar='DIR',\n                       help='Scan directory for code examples and update terminology (default: current dir)')\n    parser.add_argument('--max-scan-files', type=int, default=50,\n                       help='Maximum files to scan for code examples (default: 50)')\n\n    # Output options\n    parser.add_argument('--verbose', '-v', action='store_true',\n                       help='Enable verbose logging')\n    parser.add_argument('--quiet', '-q', action='store_true',\n                       help='Suppress non-essential output')\n    parser.add_argument('--version', action='version', version=f'doc-generator {__version__}')\n\n    return parser.parse_args()\n</code></pre>"},{"location":"api/cli/#doc_generator.cli.run_generation","title":"<code>run_generation(args, logger)</code>","text":"<p>Run the main documentation generation process.</p> Source code in <code>src/doc_generator/cli.py</code> <pre><code>def run_generation(args, logger: logging.Logger) -&gt; None:\n    \"\"\"Run the main documentation generation process.\"\"\"\n    # Load environment variables\n    load_dotenv()\n\n    # Check for API key (not needed for --list-plugins)\n    if not args.list_plugins and not os.getenv('OPENAI_API_KEY'):\n        logger.error(\"OPENAI_API_KEY environment variable not set\")\n        sys.exit(1)\n\n    try:\n        # Initialize generator\n        logger.info(\"Initializing documentation generator...\")\n        generator = DocumentationGenerator(\n            prompt_yaml_path=args.prompt_yaml_path,\n            examples_dir=args.examples_dir,\n            terminology_path=args.terminology_path,\n            logger=logger\n        )\n\n        # List plugins if requested\n        if args.list_plugins:\n            list_plugins(generator)\n            return\n\n        # Filter plugins if requested\n        if args.disable_plugins:\n            for plugin_name in args.disable_plugins:\n                if plugin_name in generator.plugin_manager.engines:\n                    del generator.plugin_manager.engines[plugin_name]\n                    logger.info(f\"Disabled plugin: {plugin_name}\")\n\n        if args.enable_only:\n            enabled_plugins = set(args.enable_only)\n            disabled = []\n            for plugin_name in list(generator.plugin_manager.engines.keys()):\n                if plugin_name not in enabled_plugins:\n                    del generator.plugin_manager.engines[plugin_name]\n                    disabled.append(plugin_name)\n            if disabled:\n                logger.info(f\"Disabled plugins: {', '.join(disabled)}\")\n\n        # Validate topic is provided for generation\n        if not args.topic and not args.list_plugins:\n            logger.error(\"--topic is required for documentation generation\")\n            sys.exit(1)\n\n        # Skip generation if just listing plugins\n        if args.list_plugins:\n            return\n\n        # Generate documentation\n        logger.info(f\"Generating documentation for topic: '{args.topic}'\")\n        logger.info(f\"Model: {args.model}, Temperature: {args.temperature}, Runs: {args.runs}\")\n\n        results = generator.generate_documentation(\n            query=args.topic,\n            runs=args.runs,\n            model=args.model,\n            temperature=args.temperature,\n            output_dir=args.output_dir\n        )\n\n        if not results:\n            logger.error(\"No documentation generated\")\n            sys.exit(1)\n\n        logger.info(f\"Generated {len(results)} documentation variants\")\n\n        # Print output file paths\n        if not args.quiet:\n            print(\"\\nGenerated Files:\")\n            for i, result in enumerate(results, 1):\n                filename = result.get('filename', f'output_{i}.html')\n                print(f\"  {i}. {filename}\")\n\n        # Run analysis if requested\n        if args.analyze:\n            logger.info(\"Running document analysis...\")\n            analyzer = DocumentAnalyzer()\n\n            for i, result in enumerate(results):\n                content = result.get('content', '')\n                if content:\n                    sections = analyzer.extract_sections(content)\n                    logger.info(f\"Variant {i+1}: Found {len(sections)} sections\")\n\n        # Run quality evaluation if requested\n        if args.quality_eval:\n            logger.info(\"Running GPT-based quality evaluation...\")\n            try:\n                evaluator = GPTQualityEvaluator(\n                    generator.client,\n                    analysis_prompt_path=args.analysis_prompt_path\n                )\n\n                for i, result in enumerate(results):\n                    content = result.get('content', '')\n                    if content:\n                        # This is a simplified evaluation - full implementation would\n                        # evaluate each section separately\n                        logger.info(f\"Evaluating variant {i+1}...\")\n\n            except Exception as e:\n                logger.warning(f\"Quality evaluation failed: {e}\")\n\n        logger.info(\"Documentation generation completed successfully\")\n\n    except Exception as e:\n        logger.error(f\"Error during generation: {e}\")\n        if args.verbose:\n            import traceback\n            traceback.print_exc()\n        sys.exit(1)\n</code></pre>"},{"location":"api/cli/#doc_generator.cli.scan_code_examples","title":"<code>scan_code_examples(args, logger)</code>","text":"<p>Scan directory for code examples and update terminology.</p> Source code in <code>src/doc_generator/cli.py</code> <pre><code>def scan_code_examples(args, logger: logging.Logger) -&gt; None:\n    \"\"\"Scan directory for code examples and update terminology.\"\"\"\n    logger.info(f\"Scanning {args.scan_code} for code examples...\")\n\n    scanner = CodeExampleScanner()\n\n    try:\n        # Scan directory\n        code_examples = scanner.scan_directory(\n            args.scan_code, \n            max_files=args.max_scan_files\n        )\n\n        if not code_examples:\n            logger.warning(\"No code examples found.\")\n            return\n\n        logger.info(f\"Found {len(code_examples)} code examples\")\n\n        # Update terminology file\n        scanner.update_terminology_file(args.terminology_path, code_examples)\n        logger.info(f\"Updated terminology file: {args.terminology_path}\")\n\n        # Show summary\n        languages = {}\n        for example in code_examples:\n            lang = example['language']\n            languages[lang] = languages.get(lang, 0) + 1\n\n        print(\"\\nCode Examples Summary:\")\n        for lang, count in sorted(languages.items()):\n            print(f\"  {lang}: {count} files\")\n\n    except Exception as e:\n        logger.error(f\"Error scanning code examples: {e}\")\n        sys.exit(1)\n</code></pre>"},{"location":"api/cli/#doc_generator.cli.setup_logging","title":"<code>setup_logging(verbose=False)</code>","text":"<p>Set up logging configuration.</p> Source code in <code>src/doc_generator/cli.py</code> <pre><code>def setup_logging(verbose: bool = False) -&gt; logging.Logger:\n    \"\"\"Set up logging configuration.\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logging.basicConfig(\n        level=level,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S'\n    )\n    return logging.getLogger('doc_generator')\n</code></pre>"},{"location":"api/cli/#command-line-arguments","title":"Command-Line Arguments","text":"<p>The CLI accepts the following arguments:</p>"},{"location":"api/cli/#core-arguments","title":"Core Arguments","text":"Argument Type Description Default <code>--topic</code> <code>str</code> Topic for documentation generation Required <code>--output-dir</code> <code>str</code> Output directory for generated files <code>output</code> <code>--runs</code> <code>int</code> Number of documentation variants to generate <code>1</code> <code>--model</code> <code>str</code> OpenAI model to use <code>gpt-4o-mini</code> <code>--temperature</code> <code>float</code> Generation temperature (0.0-1.0) <code>0.3</code>"},{"location":"api/cli/#configuration-arguments","title":"Configuration Arguments","text":"Argument Type Description Default <code>--prompt-yaml</code> <code>str</code> Path to prompt template file <code>prompts/generator/default.yaml</code> <code>--terminology-path</code> <code>str</code> Path to terminology YAML file <code>terminology.yaml</code> <code>--examples-dir</code> <code>str</code> Directory containing few-shot examples <code>examples</code>"},{"location":"api/cli/#plugin-arguments","title":"Plugin Arguments","text":"Argument Type Description Default <code>--list-plugins</code> <code>flag</code> List all available plugins and exit <code>False</code> <code>--disable-plugins</code> <code>str</code> Comma-separated list of plugins to disable <code>None</code> <code>--enable-only</code> <code>str</code> Only enable specified plugins (comma-separated) <code>None</code>"},{"location":"api/cli/#analysis-arguments","title":"Analysis Arguments","text":"Argument Type Description Default <code>--analyze</code> <code>flag</code> Run document analysis after generation <code>False</code> <code>--quality-eval</code> <code>flag</code> Run GPT-based quality evaluation <code>False</code> <code>--scan-code</code> <code>str</code> Directory to scan for code examples <code>None</code> <code>--max-scan-files</code> <code>int</code> Maximum files to scan for code examples <code>100</code>"},{"location":"api/cli/#output-arguments","title":"Output Arguments","text":"Argument Type Description Default <code>--verbose</code> <code>flag</code> Enable verbose logging output <code>False</code> <code>--dry-run</code> <code>flag</code> Show what would be done without executing <code>False</code>"},{"location":"api/cli/#usage-examples","title":"Usage Examples","text":""},{"location":"api/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>doc-gen --topic \"Python Programming\" --output-dir ./docs\n</code></pre>"},{"location":"api/cli/#advanced-generation","title":"Advanced Generation","text":"<pre><code>doc-gen \\\n  --topic \"Machine Learning with GPU\" \\\n  --runs 3 \\\n  --model gpt-4 \\\n  --temperature 0.5 \\\n  --analyze \\\n  --quality-eval \\\n  --verbose\n</code></pre>"},{"location":"api/cli/#plugin-management","title":"Plugin Management","text":"<pre><code># List available plugins\ndoc-gen --list-plugins\n\n# Disable specific plugins\ndoc-gen --topic \"Topic\" --disable-plugins modules,datasets\n\n# Enable only specific plugins  \ndoc-gen --topic \"Topic\" --enable-only workflows,templates\n</code></pre>"},{"location":"api/cli/#custom-configuration","title":"Custom Configuration","text":"<pre><code>doc-gen \\\n  --topic \"Custom Documentation\" \\\n  --prompt-yaml ./custom-prompts/api-docs.yaml \\\n  --terminology-path ./config/custom-terms.yaml \\\n  --examples-dir ./examples/specialized/\n</code></pre>"},{"location":"api/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> General error <code>2</code> Invalid arguments <code>3</code> Configuration error <code>4</code> Plugin error <code>5</code> API error (OpenAI)"},{"location":"api/core/","title":"Core API","text":"<p>The core module contains the main classes for documentation generation, analysis, and quality evaluation.</p>"},{"location":"api/core/#documentationgenerator","title":"DocumentationGenerator","text":""},{"location":"api/core/#doc_generator.core.DocumentationGenerator","title":"<code>doc_generator.core.DocumentationGenerator(prompt_yaml_path='./prompts/generator/default.yaml', examples_dir='examples/', terminology_path='terminology.yaml', logger=None)</code>","text":"<p>Main class for generating documentation using OpenAI GPT models with plugin support.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def __init__(self, prompt_yaml_path: str = './prompts/generator/default.yaml', examples_dir: str = 'examples/',\n             terminology_path: str = 'terminology.yaml', logger: Optional[logging.Logger] = None):\n    \"\"\"Initialize the documentation generator with configuration.\"\"\"\n    self.logger = logger or logging.getLogger(__name__)\n    self.client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))\n    self.examples_dir = Path(examples_dir)\n    self.prompt_config = self._load_prompt_config(prompt_yaml_path)\n    self.terminology = self._load_terminology(terminology_path)\n    self.examples = self._load_examples()\n\n    # Initialize plugin manager\n    self.plugin_manager = PluginManager(\n        terminology=self.terminology,\n        logger=self.logger\n    )\n    self.plugin_manager.load_plugins()\n</code></pre>"},{"location":"api/core/#doc_generator.core.DocumentationGenerator-functions","title":"Functions","text":""},{"location":"api/core/#doc_generator.core.DocumentationGenerator.generate_documentation","title":"<code>generate_documentation(query, runs=5, model='gpt-4', temperature=0.7, topic_filename=None, output_dir='output')</code>","text":"<p>Generate multiple documentation pages based on the query.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def generate_documentation(self, query: str, runs: int = 5, \n                         model: str = 'gpt-4', \n                         temperature: float = 0.7,\n                         topic_filename: str = None,\n                         output_dir: str = 'output') -&gt; List[str]:\n    \"\"\"Generate multiple documentation pages based on the query.\"\"\"\n    if topic_filename is None:\n        topic_filename = self._extract_topic_from_query(query)\n\n    # Extract topic for terminology context\n    topic = self._extract_topic_from_query(query).replace('_', ' ')\n\n    generated_files = []\n\n    # Build messages with topic-aware system prompt\n    system_prompt = self._build_system_prompt(topic)\n\n    for i in range(runs):\n        try:\n            messages = [\n                {'role': 'system', 'content': system_prompt}\n            ]\n\n            # Add few-shot examples\n            for example in self.examples:\n                # Only add role and content, skip metadata\n                messages.append({\n                    'role': example['role'],\n                    'content': example['content']\n                })\n\n            # Add the actual query\n            messages.append({'role': 'user', 'content': query})\n\n            # Make API call\n            response = self.client.chat.completions.create(\n                model=model,\n                messages=messages,\n                temperature=temperature\n            )\n\n            content = response.choices[0].message.content.strip()\n\n            # Generate filename based on topic, model, temperature, and iteration\n            # Clean model name (remove special characters)\n            model_name = model.replace('-', '').replace('.', '')\n            temp_str = str(temperature).replace('.', '')\n\n            if runs == 1:\n                filename = f'{topic_filename}_{model_name}_temp{temp_str}.html'\n            else:\n                filename = f'{topic_filename}_{model_name}_temp{temp_str}_v{i+1}.html'                \n            # Save the response\n            output_path = Path(output_dir)\n            output_path.mkdir(exist_ok=True)\n\n            filepath = output_path / filename\n            with open(filepath, 'w', encoding='utf-8') as f:\n                f.write(content)\n\n            generated_files.append(str(filepath))\n            print(f\"\u2713 Generated: {filepath}\")\n\n        except Exception as e:\n            print(f\"\u2717 Error generating documentation (run {i+1}): {e}\")\n\n    return generated_files\n</code></pre>"},{"location":"api/core/#documentanalyzer","title":"DocumentAnalyzer","text":""},{"location":"api/core/#doc_generator.core.DocumentAnalyzer","title":"<code>doc_generator.core.DocumentAnalyzer(section_headers=None)</code>","text":"<p>Analyze and extract sections from HTML documentation.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def __init__(self, section_headers: List[str] = None):\n    self.section_headers = section_headers or [\n        'Description', 'Installation', 'Usage', 'Examples', 'References'\n    ]\n</code></pre>"},{"location":"api/core/#doc_generator.core.DocumentAnalyzer-functions","title":"Functions","text":""},{"location":"api/core/#doc_generator.core.DocumentAnalyzer.calculate_section_score","title":"<code>calculate_section_score(section_content, section_name)</code>","text":"<p>Calculate a quality score for a section.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def calculate_section_score(self, section_content: str, section_name: str) -&gt; float:\n    \"\"\"Calculate a quality score for a section.\"\"\"\n    if not section_content:\n        return 0.0\n\n    soup = BeautifulSoup(section_content, 'html.parser')\n    text = soup.get_text().strip()\n\n    # Base score on multiple factors\n    score = 0.0\n\n    # Length (not too short, not too long)\n    word_count = len(text.split())\n    if section_name == \"Description\":\n        ideal_length = 150\n        score += max(0, 1 - abs(word_count - ideal_length) / ideal_length) * 20\n    else:\n        score += min(word_count / 100, 1) * 20  # Longer is generally better for other sections\n\n    # Code examples (for Installation, Usage, Examples)\n    if section_name in [\"Installation\", \"Usage\", \"Examples\"]:\n        code_blocks = soup.find_all(['code', 'pre'])\n        score += min(len(code_blocks) * 10, 30)\n\n    # Lists (good for organization)\n    lists = soup.find_all(['ul', 'ol'])\n    score += min(len(lists) * 5, 15)\n\n    # Links (good for References)\n    if section_name == \"References\":\n        links = soup.find_all('a')\n        score += min(len(links) * 10, 30)\n    else:\n        links = soup.find_all('a')\n        score += min(len(links) * 2, 10)\n\n    # Formatting variety (bold, italic, etc.)\n    formatting_tags = soup.find_all(['strong', 'em', 'b', 'i'])\n    score += min(len(formatting_tags) * 2, 10)\n\n    # Clarity (sentences not too long)\n    sentences = text.split('.')\n    avg_sentence_length = sum(len(s.split()) for s in sentences) / max(len(sentences), 1)\n    if 10 &lt;= avg_sentence_length &lt;= 25:\n        score += 15\n\n    return min(score, 100)  # Cap at 100\n</code></pre>"},{"location":"api/core/#doc_generator.core.DocumentAnalyzer.extract_sections","title":"<code>extract_sections(html_content)</code>","text":"<p>Extract sections from HTML content based on headers.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def extract_sections(self, html_content: str) -&gt; Dict[str, str]:\n    \"\"\"Extract sections from HTML content based on headers.\"\"\"\n    soup = BeautifulSoup(html_content, 'html.parser')\n    sections = {}\n\n    # Find all headers (h1, h2, h3, etc.)\n    headers = soup.find_all(['h1', 'h2', 'h3', 'h4'])\n\n    for i, header in enumerate(headers):\n        header_text = header.get_text().strip()\n\n        # Check if this header matches any of our target sections\n        for section_name in self.section_headers:\n            if section_name.lower() in header_text.lower():\n                # Extract content between this header and the next\n                content_parts = []\n\n                # Get all siblings until the next header\n                for sibling in header.find_next_siblings():\n                    if sibling.name in ['h1', 'h2', 'h3', 'h4']:\n                        break\n                    content_parts.append(str(sibling))\n\n                sections[section_name] = '\\n'.join(content_parts)\n                break\n\n    return sections\n</code></pre>"},{"location":"api/core/#gptqualityevaluator","title":"GPTQualityEvaluator","text":""},{"location":"api/core/#doc_generator.core.GPTQualityEvaluator","title":"<code>doc_generator.core.GPTQualityEvaluator(client, model='gpt-4', analysis_prompt_path='./prompts/analysis/default.yaml')</code>","text":"<p>Evaluate documentation quality using GPT for subjective metrics.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def __init__(self, client, model='gpt-4', analysis_prompt_path='./prompts/analysis/default.yaml'):\n    self.client = client\n    self.model = model\n    self.analysis_prompt_path = analysis_prompt_path\n    self.analysis_config = self._load_analysis_config(analysis_prompt_path)\n</code></pre>"},{"location":"api/core/#doc_generator.core.GPTQualityEvaluator-functions","title":"Functions","text":""},{"location":"api/core/#doc_generator.core.GPTQualityEvaluator.create_evaluation_prompt","title":"<code>create_evaluation_prompt(section_content, section_name, topic, criteria)</code>","text":"<p>Create a prompt for evaluating specific quality criteria.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def create_evaluation_prompt(self, section_content: str, section_name: str, \n                           topic: str, criteria: str) -&gt; str:\n    \"\"\"Create a prompt for evaluating specific quality criteria.\"\"\"\n\n    # Only use configured prompts from YAML file\n    if not self.analysis_config or 'analysis_prompts' not in self.analysis_config:\n        raise ValueError(f\"Analysis configuration not found. Please ensure {self.analysis_prompt_path} exists and contains 'analysis_prompts' section.\")\n\n    template = self.analysis_config['analysis_prompts'].get(criteria)\n    if not template:\n        raise ValueError(f\"Analysis prompt for criteria '{criteria}' not found in configuration.\")\n\n    return template.format(\n        section_name=section_name,\n        topic=topic,\n        content=section_content\n    )\n</code></pre>"},{"location":"api/core/#doc_generator.core.GPTQualityEvaluator.evaluate_section","title":"<code>evaluate_section(section_content, section_name, topic, criteria=None)</code>","text":"<p>Evaluate a section on multiple criteria.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def evaluate_section(self, section_content: str, section_name: str, \n                    topic: str, criteria: List[str] = None) -&gt; Dict[str, Dict]:\n    \"\"\"Evaluate a section on multiple criteria.\"\"\"\n    if criteria is None:\n        criteria = ['technical_accuracy', 'writing_style', 'completeness']\n\n    results = {}\n\n    for criterion in criteria:\n        if not section_content.strip():\n            results[criterion] = {\n                'score': 0,\n                'explanation': 'Section is empty'\n            }\n            continue\n\n        # Truncate very long sections\n        max_chars = 3000\n        content = section_content[:max_chars] + \"...\" if len(section_content) &gt; max_chars else section_content\n\n        prompt = self.create_evaluation_prompt(content, section_name, topic, criterion)\n\n        try:\n            response = self.client.chat.completions.create(\n                model=self.model,\n                messages=[\n                    {\"role\": \"system\", \"content\": \"You are an expert technical documentation reviewer.\"},\n                    {\"role\": \"user\", \"content\": prompt}\n                ],\n                temperature=0.3,\n                max_tokens=150\n            )\n\n            score, explanation = self.parse_gpt_response(response.choices[0].message.content)\n            results[criterion] = {\n                'score': score,\n                'explanation': explanation\n            }\n\n        except Exception as e:\n            results[criterion] = {\n                'score': 0,\n                'explanation': f'Error: {str(e)}'\n            }\n\n        # Rate limiting\n        time.sleep(0.5)\n\n    return results\n</code></pre>"},{"location":"api/core/#doc_generator.core.GPTQualityEvaluator.parse_gpt_response","title":"<code>parse_gpt_response(response)</code>","text":"<p>Parse the GPT response to extract score and explanation.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def parse_gpt_response(self, response: str) -&gt; Tuple[float, str]:\n    \"\"\"Parse the GPT response to extract score and explanation.\"\"\"\n    try:\n        # Try to parse as JSON first\n        result = json.loads(response)\n        return result['score'], result['explanation']\n    except:\n        # Fallback: extract number and text\n        import re\n        score_match = re.search(r'\\b(\\d+)\\b', response)\n        score = float(score_match.group(1)) if score_match else 50.0\n\n        # Extract explanation (everything after the score)\n        explanation = response.split(str(int(score)), 1)[-1].strip()\n        return score, explanation\n</code></pre>"},{"location":"api/core/#codeexamplescanner","title":"CodeExampleScanner","text":""},{"location":"api/core/#doc_generator.core.CodeExampleScanner","title":"<code>doc_generator.core.CodeExampleScanner()</code>","text":"<p>Scan filesystem for code examples and manage terminology metadata.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def __init__(self):\n    # Try to import pygments for language detection\n    try:\n        from pygments.lexers import get_lexer_for_filename\n        from pygments.util import ClassNotFound\n        self.get_lexer_for_filename = get_lexer_for_filename\n        self.ClassNotFound = ClassNotFound\n        self.has_pygments = True\n    except ImportError:\n        print(\"Warning: pygments not found. Install with: pip install pygments\")\n        self.has_pygments = False\n</code></pre>"},{"location":"api/core/#doc_generator.core.CodeExampleScanner-functions","title":"Functions","text":""},{"location":"api/core/#doc_generator.core.CodeExampleScanner.check_for_updates","title":"<code>check_for_updates(terminology_path)</code>","text":"<p>Check if any code examples have been updated since last scan.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def check_for_updates(self, terminology_path: str) -&gt; List[str]:\n    \"\"\"Check if any code examples have been updated since last scan.\"\"\"\n    try:\n        with open(terminology_path, 'r') as f:\n            terminology = yaml.safe_load(f) or {}\n    except FileNotFoundError:\n        return []\n\n    code_examples = terminology.get('code_examples', {})\n    updated_files = []\n\n    for language, examples in code_examples.items():\n        for example in examples:\n            file_path = Path(example['file_path'])\n            if file_path.exists():\n                current_hash = self._calculate_file_hash(file_path)\n                stored_hash = example.get('file_hash', '')\n\n                if current_hash != stored_hash:\n                    updated_files.append(str(file_path))\n\n    return updated_files\n</code></pre>"},{"location":"api/core/#doc_generator.core.CodeExampleScanner.scan_directory","title":"<code>scan_directory(scan_path, max_files=100)</code>","text":"<p>Scan directory for code examples.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def scan_directory(self, scan_path: str, max_files: int = 100) -&gt; List[Dict]:\n    \"\"\"Scan directory for code examples.\"\"\"\n    scan_path = Path(scan_path).resolve()\n\n    if not scan_path.exists():\n        raise ValueError(f\"Path does not exist: {scan_path}\")\n\n    print(f\"\ud83d\udd0d Scanning {scan_path} for code examples...\")\n\n    code_examples = []\n    file_count = 0\n\n    # Walk through directory tree\n    for file_path in scan_path.rglob('*'):\n        if file_count &gt;= max_files:\n            print(f\"\u26a0\ufe0f  Reached maximum file limit ({max_files})\")\n            break\n\n        if file_path.is_file():\n            file_info = self._extract_file_info(file_path)\n            if file_info:\n                code_examples.append(file_info)\n                file_count += 1\n                if file_count % 10 == 0:\n                    print(f\"   Processed {file_count} files...\")\n\n    print(f\"\u2705 Found {len(code_examples)} code examples\")\n    return code_examples\n</code></pre>"},{"location":"api/core/#doc_generator.core.CodeExampleScanner.update_terminology_file","title":"<code>update_terminology_file(terminology_path, code_examples)</code>","text":"<p>Update terminology file with code examples.</p> Source code in <code>src/doc_generator/core.py</code> <pre><code>def update_terminology_file(self, terminology_path: str, code_examples: List[Dict]) -&gt; None:\n    \"\"\"Update terminology file with code examples.\"\"\"\n    try:\n        with open(terminology_path, 'r') as f:\n            terminology = yaml.safe_load(f) or {}\n    except FileNotFoundError:\n        terminology = {}\n\n    # Organize examples by language\n    examples_by_language = {}\n    for example in code_examples:\n        language = example['language']\n        if language not in examples_by_language:\n            examples_by_language[language] = []\n        examples_by_language[language].append(example)\n\n    # Update terminology with code examples\n    if 'code_examples' not in terminology:\n        terminology['code_examples'] = {}\n\n    for language, examples in examples_by_language.items():\n        terminology['code_examples'][language] = examples\n\n    # Add metadata about the scan\n    terminology['code_examples_metadata'] = {\n        'last_scan': datetime.now().isoformat(),\n        'total_examples': len(code_examples),\n        'languages': list(examples_by_language.keys()),\n        'scan_summary': {lang: len(examples) for lang, examples in examples_by_language.items()}\n    }\n\n    # Write updated terminology\n    with open(terminology_path, 'w') as f:\n        yaml.dump(terminology, f, default_flow_style=False, sort_keys=False, indent=2)\n\n    print(f\"\u2705 Updated {terminology_path} with {len(code_examples)} code examples\")\n    print(f\"   Languages found: {', '.join(examples_by_language.keys())}\")\n</code></pre>"},{"location":"api/plugins/","title":"Plugin System API","text":"<p>The plugin system provides extensible recommendation engines through a well-defined interface.</p>"},{"location":"api/plugins/#pluginmanager","title":"PluginManager","text":""},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager","title":"<code>doc_generator.plugin_manager.PluginManager(terminology=None, logger=None)</code>","text":"<p>Manages discovery, loading, and execution of recommendation engine plugins.</p> <p>Parameters:</p> Name Type Description Default <code>terminology</code> <code>Optional[Dict]</code> <p>Terminology configuration to pass to plugins</p> <code>None</code> <code>logger</code> <code>Optional[Logger]</code> <p>Logger instance</p> <code>None</code> Source code in <code>src/doc_generator/plugin_manager.py</code> <pre><code>def __init__(self, terminology: Optional[Dict] = None, logger: Optional[logging.Logger] = None):\n    \"\"\"\n    Initialize the plugin manager.\n\n    Args:\n        terminology: Terminology configuration to pass to plugins\n        logger: Logger instance\n    \"\"\"\n    self.terminology = terminology or {}\n    self.logger = logger or logging.getLogger(__name__)\n    self.engines: Dict[str, RecommendationEngine] = {}\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager-functions","title":"Functions","text":""},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager.get_all_engines","title":"<code>get_all_engines()</code>","text":"<p>Get all loaded recommendation engines.</p> <p>Returns:</p> Type Description <code>Dict[str, RecommendationEngine]</code> <p>Dictionary mapping engine names to engine instances</p> Source code in <code>src/doc_generator/plugin_manager.py</code> <pre><code>def get_all_engines(self) -&gt; Dict[str, RecommendationEngine]:\n    \"\"\"\n    Get all loaded recommendation engines.\n\n    Returns:\n        Dictionary mapping engine names to engine instances\n    \"\"\"\n    return self.engines.copy()\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager.get_engine","title":"<code>get_engine(name)</code>","text":"<p>Get a specific recommendation engine by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the recommendation engine</p> required <p>Returns:</p> Type Description <code>Optional[RecommendationEngine]</code> <p>RecommendationEngine instance or None if not found</p> Source code in <code>src/doc_generator/plugin_manager.py</code> <pre><code>def get_engine(self, name: str) -&gt; Optional[RecommendationEngine]:\n    \"\"\"\n    Get a specific recommendation engine by name.\n\n    Args:\n        name: Name of the recommendation engine\n\n    Returns:\n        RecommendationEngine instance or None if not found\n    \"\"\"\n    return self.engines.get(name)\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager.get_formatted_recommendations","title":"<code>get_formatted_recommendations(topic, context=None, engine_names=None)</code>","text":"<p>Get formatted recommendations from all engines for documentation context.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Topic to get recommendations for</p> required <code>context</code> <code>Optional[Dict]</code> <p>Optional context information</p> <code>None</code> <code>engine_names</code> <code>Optional[List[str]]</code> <p>List of specific engines to use (None = all engines)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string with all recommendations</p> Source code in <code>src/doc_generator/plugin_manager.py</code> <pre><code>def get_formatted_recommendations(self, topic: str, context: Optional[Dict] = None,\n                                engine_names: Optional[List[str]] = None) -&gt; str:\n    \"\"\"\n    Get formatted recommendations from all engines for documentation context.\n\n    Args:\n        topic: Topic to get recommendations for\n        context: Optional context information\n        engine_names: List of specific engines to use (None = all engines)\n\n    Returns:\n        Formatted string with all recommendations\n    \"\"\"\n    if engine_names is None:\n        # Sort engines by priority (highest first)\n        sorted_engines = sorted(\n            self.engines.items(),\n            key=lambda x: x[1].get_priority(),\n            reverse=True\n        )\n        engine_names = [name for name, _ in sorted_engines]\n\n    formatted_parts = []\n\n    for engine_name in engine_names:\n        if engine_name not in self.engines:\n            continue\n\n        try:\n            engine = self.engines[engine_name]\n            formatted = engine.get_formatted_recommendations(topic, context)\n            if formatted.strip():\n                formatted_parts.append(formatted)\n\n        except Exception as e:\n            self.logger.error(f\"Error formatting recommendations from engine '{engine_name}': {e}\")\n\n    return \"\\n\".join(formatted_parts)\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager.get_recommendations","title":"<code>get_recommendations(topic, context=None, engine_names=None)</code>","text":"<p>Get recommendations from one or more engines.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Topic to get recommendations for</p> required <code>context</code> <code>Optional[Dict]</code> <p>Optional context information</p> <code>None</code> <code>engine_names</code> <code>Optional[List[str]]</code> <p>List of specific engines to use (None = all engines)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, List[Dict]]</code> <p>Dictionary mapping engine names to their recommendation lists</p> Source code in <code>src/doc_generator/plugin_manager.py</code> <pre><code>def get_recommendations(self, topic: str, context: Optional[Dict] = None, \n                      engine_names: Optional[List[str]] = None) -&gt; Dict[str, List[Dict]]:\n    \"\"\"\n    Get recommendations from one or more engines.\n\n    Args:\n        topic: Topic to get recommendations for\n        context: Optional context information\n        engine_names: List of specific engines to use (None = all engines)\n\n    Returns:\n        Dictionary mapping engine names to their recommendation lists\n    \"\"\"\n    if engine_names is None:\n        engine_names = list(self.engines.keys())\n\n    results = {}\n\n    for engine_name in engine_names:\n        if engine_name not in self.engines:\n            self.logger.warning(f\"Unknown recommendation engine: {engine_name}\")\n            continue\n\n        try:\n            engine = self.engines[engine_name]\n            recommendations = engine.get_recommendations(topic, context)\n            results[engine_name] = recommendations\n            self.logger.debug(f\"Engine '{engine_name}' returned {len(recommendations)} recommendations\")\n\n        except Exception as e:\n            self.logger.error(f\"Error getting recommendations from engine '{engine_name}': {e}\")\n            results[engine_name] = []\n\n    return results\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager.list_engines","title":"<code>list_engines()</code>","text":"<p>List all loaded engines with their metadata.</p> <p>Returns:</p> Type Description <code>List[Dict[str, any]]</code> <p>List of dictionaries with engine information</p> Source code in <code>src/doc_generator/plugin_manager.py</code> <pre><code>def list_engines(self) -&gt; List[Dict[str, any]]:\n    \"\"\"\n    List all loaded engines with their metadata.\n\n    Returns:\n        List of dictionaries with engine information\n    \"\"\"\n    engine_info = []\n\n    for name, engine in self.engines.items():\n        info = {\n            'name': name,\n            'class': engine.__class__.__name__,\n            'module': engine.__class__.__module__,\n            'supported_types': engine.get_supported_types(),\n            'priority': engine.get_priority(),\n            'enabled': engine.is_enabled()\n        }\n        engine_info.append(info)\n\n    return engine_info\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugin_manager.PluginManager.load_plugins","title":"<code>load_plugins()</code>","text":"<p>Discover and load all available recommendation engine plugins.</p> <p>Looks for plugins registered under the 'doc_generator.plugins' entry point group.</p> Source code in <code>src/doc_generator/plugin_manager.py</code> <pre><code>def load_plugins(self) -&gt; None:\n    \"\"\"\n    Discover and load all available recommendation engine plugins.\n\n    Looks for plugins registered under the 'doc_generator.plugins' entry point group.\n    \"\"\"\n    self.logger.info(\"Loading recommendation engine plugins...\")\n\n    try:\n        # Discover plugins via entry points\n        eps = entry_points(group='doc_generator.plugins')\n\n        for entry_point in eps:\n            try:\n                self._load_plugin(entry_point)\n            except Exception as e:\n                self.logger.warning(f\"Failed to load plugin '{entry_point.name}': {e}\")\n\n        self.logger.info(f\"Successfully loaded {len(self.engines)} plugins: {list(self.engines.keys())}\")\n\n    except Exception as e:\n        self.logger.error(f\"Error during plugin discovery: {e}\")\n</code></pre>"},{"location":"api/plugins/#recommendationengine-base-class","title":"RecommendationEngine (Base Class)","text":""},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine","title":"<code>doc_generator.plugins.base.RecommendationEngine(terminology=None, logger=None, **kwargs)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all recommendation engines.</p> <p>Recommendation engines analyze a topic and provide relevant recommendations such as HPC modules, datasets, code examples, workflows, etc.</p> <p>Parameters:</p> Name Type Description Default <code>terminology</code> <code>Optional[Dict]</code> <p>Terminology configuration dictionary</p> <code>None</code> <code>logger</code> <code>Optional[Logger]</code> <p>Logger instance for debugging and error reporting</p> <code>None</code> <code>**kwargs</code> <p>Additional configuration parameters</p> <code>{}</code> Source code in <code>src/doc_generator/plugins/base.py</code> <pre><code>def __init__(self, terminology: Optional[Dict] = None, logger: Optional[logging.Logger] = None, **kwargs):\n    \"\"\"\n    Initialize the recommendation engine.\n\n    Args:\n        terminology: Terminology configuration dictionary\n        logger: Logger instance for debugging and error reporting\n        **kwargs: Additional configuration parameters\n    \"\"\"\n    self.terminology = terminology or {}\n    self.logger = logger or logging.getLogger(__name__)\n\n    # Store any additional configuration\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine-functions","title":"Functions","text":""},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine.get_formatted_recommendations","title":"<code>get_formatted_recommendations(topic, context=None)</code>","text":"<p>Get formatted recommendations for inclusion in documentation context.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to generate recommendations for</p> required <code>context</code> <code>Optional[Dict]</code> <p>Optional context information</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string ready for inclusion in prompt context.</p> <code>str</code> <p>Returns empty string if no recommendations available.</p> Source code in <code>src/doc_generator/plugins/base.py</code> <pre><code>def get_formatted_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; str:\n    \"\"\"\n    Get formatted recommendations for inclusion in documentation context.\n\n    Args:\n        topic: The topic to generate recommendations for\n        context: Optional context information\n\n    Returns:\n        Formatted string ready for inclusion in prompt context.\n        Returns empty string if no recommendations available.\n    \"\"\"\n    recommendations = self.get_recommendations(topic, context)\n\n    if not recommendations:\n        return \"\"\n\n    # Default formatting - plugins can override for custom formatting\n    engine_name = self.get_name().title()\n    formatted = f\"\\n## {engine_name} Recommendations:\\n\\n\"\n\n    for rec in recommendations:\n        name = rec.get('name') or rec.get('title', 'Unknown')\n        formatted += f\"**{name}**\\n\"\n\n        if 'description' in rec:\n            formatted += f\"- Description: {rec['description']}\\n\"\n\n        if 'url' in rec:\n            formatted += f\"- URL: {rec['url']}\\n\"\n\n        if 'relevance_score' in rec:\n            formatted += f\"- Relevance Score: {rec['relevance_score']}\\n\"\n\n        formatted += \"\\n\"\n\n    return formatted\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine.get_name","title":"<code>get_name()</code>  <code>abstractmethod</code>","text":"<p>Return the unique name identifier for this recommendation engine.</p> <p>Returns:</p> Type Description <code>str</code> <p>String identifier (e.g., 'modules', 'datasets', 'workflows')</p> Source code in <code>src/doc_generator/plugins/base.py</code> <pre><code>@abstractmethod\ndef get_name(self) -&gt; str:\n    \"\"\"\n    Return the unique name identifier for this recommendation engine.\n\n    Returns:\n        String identifier (e.g., 'modules', 'datasets', 'workflows')\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine.get_priority","title":"<code>get_priority()</code>","text":"<p>Get the priority of this recommendation engine. Higher numbers = higher priority for ordering recommendations.</p> <p>Returns:</p> Type Description <code>int</code> <p>Integer priority (default: 50)</p> Source code in <code>src/doc_generator/plugins/base.py</code> <pre><code>def get_priority(self) -&gt; int:\n    \"\"\"\n    Get the priority of this recommendation engine.\n    Higher numbers = higher priority for ordering recommendations.\n\n    Returns:\n        Integer priority (default: 50)\n    \"\"\"\n    return 50\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine.get_recommendations","title":"<code>get_recommendations(topic, context=None)</code>  <code>abstractmethod</code>","text":"<p>Get recommendations for the given topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to generate recommendations for</p> required <code>context</code> <code>Optional[Dict]</code> <p>Optional context information (user preferences, etc.)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List of recommendation dictionaries. Each dictionary should contain</p> <code>List[Dict]</code> <p>at minimum: name/title, description, and relevance_score fields.</p> Source code in <code>src/doc_generator/plugins/base.py</code> <pre><code>@abstractmethod\ndef get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n    \"\"\"\n    Get recommendations for the given topic.\n\n    Args:\n        topic: The topic to generate recommendations for\n        context: Optional context information (user preferences, etc.)\n\n    Returns:\n        List of recommendation dictionaries. Each dictionary should contain\n        at minimum: name/title, description, and relevance_score fields.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine.get_supported_types","title":"<code>get_supported_types()</code>","text":"<p>Return list of supported recommendation types.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of strings describing what this engine recommends</p> <code>List[str]</code> <p>(e.g., ['hpc_modules', 'software'])</p> Source code in <code>src/doc_generator/plugins/base.py</code> <pre><code>def get_supported_types(self) -&gt; List[str]:\n    \"\"\"\n    Return list of supported recommendation types.\n\n    Returns:\n        List of strings describing what this engine recommends\n        (e.g., ['hpc_modules', 'software'])\n    \"\"\"\n    return [self.get_name()]\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.base.RecommendationEngine.is_enabled","title":"<code>is_enabled()</code>","text":"<p>Check if this recommendation engine is enabled.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if enabled, False otherwise</p> Source code in <code>src/doc_generator/plugins/base.py</code> <pre><code>def is_enabled(self) -&gt; bool:\n    \"\"\"\n    Check if this recommendation engine is enabled.\n\n    Returns:\n        True if enabled, False otherwise\n    \"\"\"\n    return True  # Default to enabled\n</code></pre>"},{"location":"api/plugins/#built-in-plugins","title":"Built-in Plugins","text":""},{"location":"api/plugins/#modulerecommender","title":"ModuleRecommender","text":""},{"location":"api/plugins/#doc_generator.plugins.modules.ModuleRecommender","title":"<code>doc_generator.plugins.modules.ModuleRecommender(terminology=None, **kwargs)</code>","text":"<p>               Bases: <code>RecommendationEngine</code></p> <p>Recommendation engine for HPC modules based on topic analysis.</p> <p>This plugin analyzes topic keywords and recommends relevant HPC modules from the terminology configuration, with priority given to latest FASRC builds.</p> Source code in <code>src/doc_generator/plugins/modules.py</code> <pre><code>def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n    super().__init__(terminology, **kwargs)\n\n    # Extract HPC modules from terminology\n    self.hpc_modules = self.terminology.get('hpc_modules', [])\n\n    # Keyword mappings for different technologies\n    self.keyword_mappings = {\n        'python': ['python', 'py', 'jupyter', 'anaconda', 'conda', 'numpy', 'scipy', 'pandas'],\n        'gcc': ['c', 'cpp', 'c++', 'gnu', 'gcc', 'fortran', 'gfortran'],\n        'cuda': ['cuda', 'gpu', 'nvidia', 'cupy', 'numba'],\n        'openmpi': ['mpi', 'openmpi', 'parallel', 'distributed'],\n        'intel': ['intel', 'mkl', 'icc', 'ifort'],\n        'matlab': ['matlab', 'octave'],\n        'r': ['r', 'rstudio', 'cran'],\n        'java': ['java', 'jvm', 'scala', 'maven'],\n        'julia': ['julia', 'julialang'],\n        'tensorflow': ['tensorflow', 'tf', 'keras'],\n        'pytorch': ['pytorch', 'torch'],\n        'singularity': ['singularity', 'container', 'apptainer'],\n        'cmake': ['cmake', 'build', 'compilation'],\n        'git': ['git', 'version', 'control'],\n        'hdf5': ['hdf5', 'hdf', 'hierarchical'],\n        'netcdf': ['netcdf', 'climate', 'atmospheric']\n    }\n\n    # Stop words to filter out\n    self.stop_words = {\n        'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with',\n        'by', 'from', 'up', 'about', 'into', 'through', 'during', 'before',\n        'after', 'above', 'below', 'between', 'among', 'through', 'during',\n        'before', 'after', 'above', 'below', 'up', 'down', 'out', 'off', 'over',\n        'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when',\n        'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more',\n        'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own',\n        'same', 'so', 'than', 'too', 'very', 'can', 'will', 'just', 'should',\n        'now', 'use', 'using', 'used', 'get', 'getting', 'got', 'make', 'making',\n        'made', 'take', 'taking', 'took', 'come', 'coming', 'came', 'go', 'going',\n        'went', 'see', 'seeing', 'saw', 'know', 'knowing', 'knew', 'think',\n        'thinking', 'thought', 'say', 'saying', 'said', 'work', 'working', 'worked'\n    }\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.modules.ModuleRecommender-functions","title":"Functions","text":""},{"location":"api/plugins/#doc_generator.plugins.modules.ModuleRecommender.get_formatted_recommendations","title":"<code>get_formatted_recommendations(topic, context=None)</code>","text":"<p>Get formatted module recommendations for documentation context.</p> Source code in <code>src/doc_generator/plugins/modules.py</code> <pre><code>def get_formatted_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; str:\n    \"\"\"\n    Get formatted module recommendations for documentation context.\n    \"\"\"\n    modules = self.get_recommendations(topic, context)\n\n    if not modules:\n        return \"\"\n\n    formatted = \"\\n## Recommended Modules:\\n\\n\"\n    for module in modules:\n        formatted += f\"**{module['name']}**\\n\"\n        formatted += f\"- Load Command: `{module['load_command']}`\\n\"\n        formatted += f\"- Description: {module.get('description', 'No description available')}\\n\"\n        if 'category' in module:\n            formatted += f\"- Category: {module['category']}\\n\"\n        formatted += f\"- Relevance Score: {module['relevance_score']}\\n\\n\"\n\n    return formatted\n</code></pre>"},{"location":"api/plugins/#doc_generator.plugins.modules.ModuleRecommender.get_recommendations","title":"<code>get_recommendations(topic, context=None)</code>","text":"<p>Get HPC module recommendations for the given topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to analyze for module recommendations</p> required <code>context</code> <code>Optional[Dict]</code> <p>Optional context (unused currently)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List of recommended modules with metadata</p> Source code in <code>src/doc_generator/plugins/modules.py</code> <pre><code>def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n    \"\"\"\n    Get HPC module recommendations for the given topic.\n\n    Args:\n        topic: The topic to analyze for module recommendations\n        context: Optional context (unused currently)\n\n    Returns:\n        List of recommended modules with metadata\n    \"\"\"\n    if not self.hpc_modules:\n        self.logger.warning(\"No HPC modules available in terminology\")\n        return []\n\n    # Extract keywords from topic\n    topic_keywords = self._extract_keywords_from_topic(topic)\n    self.logger.debug(f\"Extracted keywords from '{topic}': {topic_keywords}\")\n\n    # Find matching modules\n    matching_modules = []\n    for module in self.hpc_modules:\n        relevance_score = self._calculate_module_relevance(module, topic_keywords)\n        if relevance_score &gt; 0:\n            module_copy = module.copy()\n            module_copy['relevance_score'] = relevance_score\n            module_copy['load_command'] = f\"module load {module['name']}\"\n            matching_modules.append(module_copy)\n\n    # Sort by relevance score and priority\n    matching_modules.sort(\n        key=lambda x: (x['relevance_score'], self._get_priority_score(x)),\n        reverse=True\n    )\n\n    # Return top matches (default max 3)\n    max_modules = context.get('max_modules', 3) if context else 3\n    return matching_modules[:max_modules]\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced Workflows","text":"<p>This page demonstrates sophisticated usage patterns, automation, and integration examples for doc-generator.</p>"},{"location":"examples/advanced/#batch-processing","title":"\ud83d\udd04 Batch Processing","text":""},{"location":"examples/advanced/#processing-multiple-topics","title":"Processing Multiple Topics","text":"<pre><code># Create topics file\ncat &gt; topics.txt &lt;&lt; 'EOF'\nPython Data Analysis with Pandas\nR Statistical Computing on HPC\nMATLAB Numerical Methods\nJulia High-Performance Computing\nFortran Parallel Programming\nEOF\n\n# Process all topics with consistent settings\nwhile IFS= read -r topic; do\n    echo \"Processing: $topic\"\n    doc-gen --topic \"$topic\" \\\n      --output-dir batch-output \\\n      --runs 2 \\\n      --model gpt-4 \\\n      --analyze\n    sleep 3  # Rate limiting\ndone &lt; topics.txt\n</code></pre>"},{"location":"examples/advanced/#parallel-processing-with-gnu-parallel","title":"Parallel Processing with GNU Parallel","text":"<pre><code># Install GNU parallel if not available\n# brew install parallel  # macOS\n# sudo apt install parallel  # Ubuntu\n\n# Process topics in parallel (be careful with API rate limits)\nparallel -j 2 --delay 5 \\\n  'doc-gen --topic \"{}\" --output-dir parallel-output --runs 1' \\\n  :::: topics.txt\n</code></pre>"},{"location":"examples/advanced/#automated-quality-assessment","title":"Automated Quality Assessment","text":"<pre><code>#!/bin/bash\n# batch-generate-with-quality.sh\n\nTOPICS=(\n    \"Deep Learning with TensorFlow\"\n    \"Containerized Applications with Singularity\"\n    \"Distributed Computing with Spark\"\n    \"Quantum Computing Simulations\"\n)\n\nOUTPUT_BASE=\"quality-docs\"\nmkdir -p \"$OUTPUT_BASE\"\n\nfor topic in \"${TOPICS[@]}\"; do\n    echo \"=== Processing: $topic ===\"\n\n    # Generate with full quality pipeline\n    doc-gen --topic \"$topic\" \\\n      --output-dir \"$OUTPUT_BASE\" \\\n      --runs 3 \\\n      --model gpt-4 \\\n      --temperature 0.3 \\\n      --analyze \\\n      --quality-eval \\\n      --verbose\n\n    echo \"\u2713 Completed: $topic\"\n    echo \"---\"\n    sleep 5\ndone\n\necho \"\ud83c\udf89 Batch processing complete!\"\necho \"Results in: $OUTPUT_BASE/\"\n</code></pre>"},{"location":"examples/advanced/#advanced-configuration","title":"\ud83c\udf9b\ufe0f Advanced Configuration","text":""},{"location":"examples/advanced/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code># .env.production\nOPENAI_API_KEY=prod-key-here\nDOC_GEN_DEFAULT_MODEL=gpt-4\nDOC_GEN_DEFAULT_TEMPERATURE=0.2\nDOC_GEN_DEFAULT_RUNS=3\nDOC_GEN_OUTPUT_DIR=production-docs\nDOC_GEN_VERBOSE=true\n\n# .env.development  \nOPENAI_API_KEY=dev-key-here\nDOC_GEN_DEFAULT_MODEL=gpt-3.5-turbo\nDOC_GEN_DEFAULT_TEMPERATURE=0.5\nDOC_GEN_DEFAULT_RUNS=1\nDOC_GEN_OUTPUT_DIR=dev-docs\nDOC_GEN_VERBOSE=false\n</code></pre> <pre><code># Use different environments\nsource .env.production &amp;&amp; doc-gen --topic \"Production Guide\"\nsource .env.development &amp;&amp; doc-gen --topic \"Development Test\"\n</code></pre>"},{"location":"examples/advanced/#multi-organization-setup","title":"Multi-Organization Setup","text":"<pre><code># config/organizations.yaml\norganizations:\n  fasrc:\n    name: \"FASRC Research Computing\"\n    prompt_template: \"prompts/generator/fasrc.yaml\"\n    terminology: \"terminology/fasrc.yaml\"\n    output_prefix: \"fasrc\"\n\n  mit:\n    name: \"MIT SuperCloud\"\n    prompt_template: \"prompts/generator/mit.yaml\"  \n    terminology: \"terminology/mit.yaml\"\n    output_prefix: \"mit\"\n</code></pre> <pre><code># Organization-specific generation script\n#!/bin/bash\ngenerate_for_org() {\n    local org=$1\n    local topic=$2\n\n    doc-gen --topic \"$topic\" \\\n      --prompt-yaml \"prompts/generator/${org}.yaml\" \\\n      --terminology-path \"terminology/${org}.yaml\" \\\n      --output-dir \"docs/${org}\" \\\n      --runs 2\n}\n\n# Generate for multiple organizations\ngenerate_for_org \"fasrc\" \"Python Machine Learning\"\ngenerate_for_org \"mit\" \"Python Machine Learning\"\n</code></pre>"},{"location":"examples/advanced/#advanced-analysis-and-quality-control","title":"\ud83e\uddea Advanced Analysis and Quality Control","text":""},{"location":"examples/advanced/#custom-quality-metrics","title":"Custom Quality Metrics","text":"<pre><code># scripts/quality_analyzer.py\nimport yaml\nimport json\nfrom pathlib import Path\nfrom doc_generator import DocumentationGenerator, DocumentAnalyzer\n\nclass AdvancedQualityAnalyzer:\n    def __init__(self):\n        self.analyzer = DocumentAnalyzer()\n        self.quality_thresholds = {\n            'min_length': 2000,\n            'min_code_examples': 2,\n            'min_sections': 4,\n            'min_links': 1\n        }\n\n    def batch_analyze(self, docs_dir: str) -&gt; dict:\n        results = {}\n        docs_path = Path(docs_dir)\n\n        for html_file in docs_path.glob(\"*.html\"):\n            with open(html_file, 'r') as f:\n                content = f.read()\n\n            analysis = self.analyzer.analyze_document(content)\n            quality_score = self.calculate_quality_score(analysis)\n\n            results[html_file.name] = {\n                'analysis': analysis,\n                'quality_score': quality_score,\n                'passes_threshold': quality_score &gt; 7.0\n            }\n\n        return results\n\n    def calculate_quality_score(self, analysis: dict) -&gt; float:\n        score = 0.0\n\n        # Length score (0-3 points)\n        length_score = min(3.0, analysis['total_length'] / 1000)\n        score += length_score\n\n        # Code examples score (0-2 points)\n        code_score = min(2.0, analysis['code_blocks'] * 0.5)\n        score += code_score\n\n        # Structure score (0-3 points)\n        section_score = min(3.0, analysis['sections'] * 0.6)\n        score += section_score\n\n        # Links score (0-2 points)\n        links_score = min(2.0, analysis['links'] * 0.4)\n        score += links_score\n\n        return round(score, 1)\n\n# Usage\nanalyzer = AdvancedQualityAnalyzer()\nresults = analyzer.batch_analyze(\"./output\")\nprint(json.dumps(results, indent=2))\n</code></pre>"},{"location":"examples/advanced/#ab-testing-framework","title":"A/B Testing Framework","text":"<pre><code># scripts/ab_testing.py\nimport random\nfrom doc_generator import DocumentationGenerator\n\nclass ABTestingFramework:\n    def __init__(self):\n        self.generator = DocumentationGenerator()\n\n    def run_temperature_test(self, topic: str, temperatures: list, runs_per_temp: int = 3):\n        \"\"\"Test different temperature settings.\"\"\"\n        results = {}\n\n        for temp in temperatures:\n            temp_results = []\n            for run in range(runs_per_temp):\n                result = self.generator.generate_documentation(\n                    query=topic,\n                    temperature=temp,\n                    runs=1\n                )[0]\n                temp_results.append(result)\n\n            results[f\"temp_{temp}\"] = temp_results\n\n        return results\n\n    def run_model_comparison(self, topic: str, models: list):\n        \"\"\"Compare different models.\"\"\"\n        results = {}\n\n        for model in models:\n            result = self.generator.generate_documentation(\n                query=topic,\n                model=model,\n                runs=1\n            )[0]\n            results[model] = result\n\n        return results\n\n# Usage\ntester = ABTestingFramework()\n\n# Test temperature variations\ntemp_results = tester.run_temperature_test(\n    \"Python Machine Learning\",\n    temperatures=[0.1, 0.3, 0.5, 0.7],\n    runs_per_temp=2\n)\n\n# Test model comparison\nmodel_results = tester.run_model_comparison(\n    \"Database Design Patterns\",\n    models=[\"gpt-3.5-turbo\", \"gpt-4\", \"gpt-4o-mini\"]\n)\n</code></pre>"},{"location":"examples/advanced/#advanced-plugin-development","title":"\ud83d\udd0c Advanced Plugin Development","text":""},{"location":"examples/advanced/#multi-source-plugin","title":"Multi-Source Plugin","text":"<pre><code># plugins/advanced_dataset_recommender.py\nimport asyncio\nimport aiohttp\nfrom typing import List, Dict, Optional\nfrom doc_generator.plugins.base import RecommendationEngine\n\nclass AdvancedDatasetRecommender(RecommendationEngine):\n    \"\"\"Advanced dataset recommender with multiple APIs and caching.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n        self.sources = [\n            {\n                'name': 'Zenodo',\n                'url': 'https://zenodo.org/api/records',\n                'parser': self._parse_zenodo\n            },\n            {\n                'name': 'DataHub',\n                'url': 'https://datahub.io/api/search',\n                'parser': self._parse_datahub\n            },\n            {\n                'name': 'NASA',\n                'url': 'https://data.nasa.gov/api/search',\n                'parser': self._parse_nasa\n            }\n        ]\n        self.cache = {}\n        self.cache_ttl = 3600  # 1 hour\n\n    async def get_recommendations_async(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Async version for better performance.\"\"\"\n        keywords = self._extract_keywords(topic)\n\n        async with aiohttp.ClientSession() as session:\n            tasks = [\n                self._search_source_async(session, source, keywords)\n                for source in self.sources\n            ]\n\n            results = await asyncio.gather(*tasks, return_exceptions=True)\n\n        # Combine and rank results\n        all_datasets = []\n        for result in results:\n            if isinstance(result, list):\n                all_datasets.extend(result)\n\n        # Sort by relevance and return top 10\n        all_datasets.sort(key=lambda x: x.get('relevance_score', 0), reverse=True)\n        return all_datasets[:10]\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Sync wrapper for async method.\"\"\"\n        try:\n            loop = asyncio.get_event_loop()\n        except RuntimeError:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n\n        return loop.run_until_complete(\n            self.get_recommendations_async(topic, context)\n        )\n\n    async def _search_source_async(self, session: aiohttp.ClientSession, source: dict, keywords: List[str]) -&gt; List[Dict]:\n        \"\"\"Search a single source asynchronously.\"\"\"\n        try:\n            query = ' '.join(keywords)\n            async with session.get(\n                source['url'],\n                params={'q': query, 'size': 5},\n                timeout=aiohttp.ClientTimeout(total=10)\n            ) as response:\n                data = await response.json()\n                return source['parser'](data, keywords)\n        except Exception as e:\n            self.logger.warning(f\"Error searching {source['name']}: {e}\")\n            return []\n\n    def _parse_zenodo(self, data: dict, keywords: List[str]) -&gt; List[Dict]:\n        \"\"\"Parse Zenodo API response.\"\"\"\n        datasets = []\n        for hit in data.get('hits', {}).get('hits', []):\n            metadata = hit.get('metadata', {})\n            dataset = {\n                'title': metadata.get('title', 'Unknown Dataset'),\n                'description': metadata.get('description', '')[:200] + '...',\n                'url': hit.get('links', {}).get('html', ''),\n                'source': 'Zenodo',\n                'relevance_score': self._calculate_relevance(metadata.get('title', ''), keywords)\n            }\n            datasets.append(dataset)\n        return datasets\n</code></pre>"},{"location":"examples/advanced/#plugin-with-machine-learning","title":"Plugin with Machine Learning","text":"<pre><code># plugins/ml_recommender.py\nimport numpy as np\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.metrics.pairwise import cosine_similarity\nfrom doc_generator.plugins.base import RecommendationEngine\n\nclass MLRecommender(RecommendationEngine):\n    \"\"\"ML-powered recommendation engine using TF-IDF similarity.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n        self.vectorizer = TfidfVectorizer(stop_words='english', max_features=1000)\n        self.knowledge_base = self._build_knowledge_base()\n        self.vectors = None\n        self._fit_vectorizer()\n\n    def _build_knowledge_base(self) -&gt; List[Dict]:\n        \"\"\"Build knowledge base from various sources.\"\"\"\n        knowledge = []\n\n        # HPC modules\n        if self.terminology and 'hpc_modules' in self.terminology:\n            for module in self.terminology['hpc_modules']:\n                knowledge.append({\n                    'type': 'module',\n                    'title': f\"HPC Module: {module['name']}\",\n                    'content': f\"{module['name']} {module.get('description', '')} {' '.join(module.get('keywords', []))}\",\n                    'recommendation': f\"module load {module['name']}\"\n                })\n\n        # Add more knowledge sources here\n        # - Documentation links\n        # - Code examples\n        # - Best practices\n\n        return knowledge\n\n    def _fit_vectorizer(self):\n        \"\"\"Fit TF-IDF vectorizer on knowledge base.\"\"\"\n        if self.knowledge_base:\n            texts = [item['content'] for item in self.knowledge_base]\n            self.vectors = self.vectorizer.fit_transform(texts)\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Get recommendations using ML similarity.\"\"\"\n        if not self.knowledge_base or self.vectors is None:\n            return []\n\n        # Vectorize the topic\n        topic_vector = self.vectorizer.transform([topic])\n\n        # Calculate similarities\n        similarities = cosine_similarity(topic_vector, self.vectors)[0]\n\n        # Get top recommendations\n        top_indices = np.argsort(similarities)[::-1][:5]\n\n        recommendations = []\n        for idx in top_indices:\n            if similarities[idx] &gt; 0.1:  # Minimum similarity threshold\n                item = self.knowledge_base[idx]\n                recommendations.append({\n                    'title': item['title'],\n                    'description': item.get('recommendation', ''),\n                    'relevance_score': float(similarities[idx]) * 10,\n                    'type': item['type']\n                })\n\n        return recommendations\n</code></pre>"},{"location":"examples/advanced/#integration-examples","title":"\ud83d\udd17 Integration Examples","text":""},{"location":"examples/advanced/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<pre><code># .github/workflows/docs-generation.yml\nname: Generate Documentation\non:\n  push:\n    paths: ['docs/topics/*.txt']\n  workflow_dispatch:\n\njobs:\n  generate-docs:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Python\n      uses: actions/setup-python@v3\n      with:\n        python-version: '3.10'\n\n    - name: Install dependencies\n      run: |\n        pip install -e .\n\n    - name: Generate documentation\n      env:\n        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n      run: |\n        python scripts/batch_generate.py\n\n    - name: Upload artifacts\n      uses: actions/upload-artifact@v3\n      with:\n        name: generated-docs\n        path: output/\n\n    - name: Deploy to GitHub Pages\n      if: github.ref == 'refs/heads/main'\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./output\n</code></pre>"},{"location":"examples/advanced/#wordpress-integration","title":"WordPress Integration","text":"<pre><code># scripts/wordpress_publisher.py\nimport requests\nfrom pathlib import Path\nimport base64\n\nclass WordPressPublisher:\n    def __init__(self, site_url: str, username: str, password: str):\n        self.site_url = site_url.rstrip('/')\n        self.api_url = f\"{self.site_url}/wp-json/wp/v2\"\n        self.auth = (username, password)\n\n    def publish_documentation(self, html_file: Path, title: str = None):\n        \"\"\"Publish generated HTML as WordPress post.\"\"\"\n        with open(html_file, 'r') as f:\n            content = f.read()\n\n        # Extract title from filename if not provided\n        if not title:\n            title = html_file.stem.replace('_', ' ').title()\n\n        post_data = {\n            'title': title,\n            'content': content,\n            'status': 'publish',\n            'categories': [1],  # Adjust category ID\n            'tags': ['documentation', 'auto-generated']\n        }\n\n        response = requests.post(\n            f\"{self.api_url}/posts\",\n            json=post_data,\n            auth=self.auth\n        )\n\n        if response.status_code == 201:\n            post_id = response.json()['id']\n            post_url = response.json()['link']\n            print(f\"\u2713 Published: {title}\")\n            print(f\"  URL: {post_url}\")\n            return post_id\n        else:\n            print(f\"\u2717 Failed to publish: {title}\")\n            print(f\"  Error: {response.text}\")\n            return None\n\n# Usage\npublisher = WordPressPublisher(\n    site_url=\"https://your-site.com\",\n    username=\"your-username\", \n    password=\"your-app-password\"\n)\n\n# Publish all generated docs\noutput_dir = Path(\"./output\")\nfor html_file in output_dir.glob(\"*.html\"):\n    publisher.publish_documentation(html_file)\n</code></pre>"},{"location":"examples/advanced/#slack-integration","title":"Slack Integration","text":"<pre><code># scripts/slack_notifier.py\nimport requests\nimport json\nfrom pathlib import Path\n\nclass SlackNotifier:\n    def __init__(self, webhook_url: str):\n        self.webhook_url = webhook_url\n\n    def notify_generation_complete(self, topic: str, output_files: list, quality_score: float = None):\n        \"\"\"Send notification when documentation generation completes.\"\"\"\n\n        message = {\n            \"text\": f\"\ud83d\udcda Documentation Generated: {topic}\",\n            \"blocks\": [\n                {\n                    \"type\": \"header\",\n                    \"text\": {\"type\": \"plain_text\", \"text\": f\"\ud83d\udcda Documentation Generated\"}\n                },\n                {\n                    \"type\": \"section\",\n                    \"fields\": [\n                        {\"type\": \"mrkdwn\", \"text\": f\"*Topic:*\\n{topic}\"},\n                        {\"type\": \"mrkdwn\", \"text\": f\"*Files:*\\n{len(output_files)} generated\"}\n                    ]\n                }\n            ]\n        }\n\n        if quality_score:\n            message[\"blocks\"].append({\n                \"type\": \"section\",\n                \"text\": {\"type\": \"mrkdwn\", \"text\": f\"*Quality Score:* {quality_score}/10\"}\n            })\n\n        # Add file list\n        file_list = \"\\n\".join([f\"\u2022 `{f}`\" for f in output_files[:5]])\n        if len(output_files) &gt; 5:\n            file_list += f\"\\n\u2022 ... and {len(output_files) - 5} more\"\n\n        message[\"blocks\"].append({\n            \"type\": \"section\",\n            \"text\": {\"type\": \"mrkdwn\", \"text\": f\"*Generated Files:*\\n{file_list}\"}\n        })\n\n        response = requests.post(self.webhook_url, json=message)\n        return response.status_code == 200\n\n# Usage in batch script\nnotifier = SlackNotifier(\"https://hooks.slack.com/services/YOUR/WEBHOOK/URL\")\nnotifier.notify_generation_complete(\n    topic=\"Python Machine Learning\",\n    output_files=[\"ml_guide_v1.html\", \"ml_guide_v2.html\"],\n    quality_score=8.5\n)\n</code></pre>"},{"location":"examples/advanced/#performance-optimization","title":"\ud83d\udcca Performance Optimization","text":""},{"location":"examples/advanced/#concurrent-processing","title":"Concurrent Processing","text":"<pre><code># scripts/concurrent_generator.py\nimport asyncio\nimport concurrent.futures\nfrom doc_generator import DocumentationGenerator\n\nclass ConcurrentGenerator:\n    def __init__(self, max_workers: int = 3):\n        self.generator = DocumentationGenerator()\n        self.max_workers = max_workers\n\n    def batch_generate(self, topics: list, **kwargs) -&gt; dict:\n        \"\"\"Generate documentation for multiple topics concurrently.\"\"\"\n        results = {}\n\n        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Submit all tasks\n            future_to_topic = {\n                executor.submit(self._generate_single, topic, **kwargs): topic\n                for topic in topics\n            }\n\n            # Collect results\n            for future in concurrent.futures.as_completed(future_to_topic):\n                topic = future_to_topic[future]\n                try:\n                    result = future.result()\n                    results[topic] = result\n                    print(f\"\u2713 Completed: {topic}\")\n                except Exception as e:\n                    print(f\"\u2717 Failed: {topic} - {e}\")\n                    results[topic] = None\n\n        return results\n\n    def _generate_single(self, topic: str, **kwargs):\n        \"\"\"Generate documentation for a single topic.\"\"\"\n        return self.generator.generate_documentation(\n            query=topic,\n            **kwargs\n        )\n\n# Usage\ngenerator = ConcurrentGenerator(max_workers=2)\ntopics = [\n    \"Python Data Science\",\n    \"R Statistical Analysis\", \n    \"Julia Numerical Computing\"\n]\n\nresults = generator.batch_generate(\n    topics,\n    runs=2,\n    model=\"gpt-4\",\n    temperature=0.3\n)\n</code></pre>"},{"location":"examples/advanced/#caching-implementation","title":"Caching Implementation","text":"<pre><code># scripts/cached_generator.py\nimport hashlib\nimport json\nimport pickle\nfrom pathlib import Path\nfrom datetime import datetime, timedelta\nfrom doc_generator import DocumentationGenerator\n\nclass CachedGenerator:\n    def __init__(self, cache_dir: str = \".cache\", cache_ttl: int = 3600):\n        self.generator = DocumentationGenerator()\n        self.cache_dir = Path(cache_dir)\n        self.cache_dir.mkdir(exist_ok=True)\n        self.cache_ttl = cache_ttl\n\n    def generate_with_cache(self, query: str, **kwargs) -&gt; list:\n        \"\"\"Generate documentation with caching.\"\"\"\n        # Create cache key\n        cache_key = self._create_cache_key(query, kwargs)\n        cache_file = self.cache_dir / f\"{cache_key}.pkl\"\n\n        # Check cache\n        if self._is_cache_valid(cache_file):\n            print(f\"\ud83d\udce6 Using cached result for: {query}\")\n            with open(cache_file, 'rb') as f:\n                return pickle.load(f)\n\n        # Generate fresh content\n        print(f\"\ud83d\udd04 Generating fresh content for: {query}\")\n        results = self.generator.generate_documentation(query=query, **kwargs)\n\n        # Cache results\n        with open(cache_file, 'wb') as f:\n            pickle.dump(results, f)\n\n        return results\n\n    def _create_cache_key(self, query: str, kwargs: dict) -&gt; str:\n        \"\"\"Create deterministic cache key.\"\"\"\n        cache_data = {'query': query, 'kwargs': kwargs}\n        cache_string = json.dumps(cache_data, sort_keys=True)\n        return hashlib.md5(cache_string.encode()).hexdigest()\n\n    def _is_cache_valid(self, cache_file: Path) -&gt; bool:\n        \"\"\"Check if cache file exists and is still valid.\"\"\"\n        if not cache_file.exists():\n            return False\n\n        file_time = datetime.fromtimestamp(cache_file.stat().st_mtime)\n        expiry_time = datetime.now() - timedelta(seconds=self.cache_ttl)\n\n        return file_time &gt; expiry_time\n\n    def clear_cache(self):\n        \"\"\"Clear all cached results.\"\"\"\n        for cache_file in self.cache_dir.glob(\"*.pkl\"):\n            cache_file.unlink()\n        print(f\"\ud83d\uddd1\ufe0f Cleared cache directory: {self.cache_dir}\")\n\n# Usage\ncached_generator = CachedGenerator(cache_ttl=7200)  # 2 hours\n\n# First call - generates fresh content\nresults1 = cached_generator.generate_with_cache(\n    \"Python Machine Learning\",\n    runs=2,\n    model=\"gpt-4\"\n)\n\n# Second call - uses cached content\nresults2 = cached_generator.generate_with_cache(\n    \"Python Machine Learning\", \n    runs=2,\n    model=\"gpt-4\"\n)\n</code></pre> <p>These advanced examples demonstrate the full power of doc-generator for sophisticated workflows, automation, and integration scenarios. For more specific use cases, check out the Plugin Examples or Basic Usage guides.</p>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>This page demonstrates basic usage patterns for doc-generator with practical examples.</p>"},{"location":"examples/basic/#getting-started-examples","title":"\ud83d\ude80 Getting Started Examples","text":""},{"location":"examples/basic/#simple-documentation-generation","title":"Simple Documentation Generation","text":"<pre><code># Generate documentation for a Python topic\ndoc-gen --topic \"Python Programming\" --output-dir ./docs\n\n# What this creates:\n# ./docs/python_programming_gpt4omini_temp03.html\n</code></pre> <p>Generated content includes: - Overview of Python programming - Installation instructions with HPC modules - Basic usage examples and syntax - Code examples and best practices - Relevant references and links</p>"},{"location":"examples/basic/#multiple-runs-for-quality","title":"Multiple Runs for Quality","text":"<pre><code># Generate 3 variants to compare quality\ndoc-gen --topic \"Machine Learning\" --runs 3 --output-dir ./ml-docs\n\n# Creates:\n# ./ml-docs/machine_learning_gpt4omini_temp03_v1.html\n# ./ml-docs/machine_learning_gpt4omini_temp03_v2.html  \n# ./ml-docs/machine_learning_gpt4omini_temp03_v3.html\n</code></pre>"},{"location":"examples/basic/#different-models-and-temperatures","title":"Different Models and Temperatures","text":"<pre><code># Use GPT-4 for higher quality\ndoc-gen --topic \"Database Design\" --model gpt-4 --temperature 0.2\n\n# Use higher temperature for more creative output\ndoc-gen --topic \"Creative Coding\" --model gpt-4 --temperature 0.8\n</code></pre>"},{"location":"examples/basic/#plugin-examples","title":"\ud83d\udd0c Plugin Examples","text":""},{"location":"examples/basic/#view-available-plugins","title":"View Available Plugins","text":"<pre><code># List all loaded plugins\ndoc-gen --list-plugins\n</code></pre> <p>Expected output: <pre><code>Available Recommendation Engine Plugins:\n==================================================\n\nPlugin: modules\n  Class: ModuleRecommender  \n  Module: doc_generator.plugins.modules\n  Supported Types: hpc_modules, software, compilers, libraries\n  Priority: 100\n  Enabled: True\n</code></pre></p>"},{"location":"examples/basic/#plugin-enhanced-documentation","title":"Plugin-Enhanced Documentation","text":"<pre><code># Generate with module recommendations\ndoc-gen --topic \"NumPy Array Processing\"\n\n# The ModuleRecommender plugin automatically adds:\n# - module load python/3.12.8-fasrc01\n# - module load gcc/12.2.0-fasrc01  \n# - Relevant module descriptions and usage\n</code></pre>"},{"location":"examples/basic/#managing-plugins","title":"Managing Plugins","text":"<pre><code># Disable all plugins for plain documentation\ndoc-gen --topic \"General Topic\" --disable-plugins modules\n\n# Enable only specific plugins (when you have multiple)\ndoc-gen --topic \"Data Science\" --enable-only modules,datasets\n</code></pre>"},{"location":"examples/basic/#output-management","title":"\ud83d\udcc1 Output Management","text":""},{"location":"examples/basic/#organized-output-structure","title":"Organized Output Structure","text":"<pre><code># Create organized documentation structure\nmkdir -p docs/{tutorials,references,guides}\n\n# Generate different types of documentation\ndoc-gen --topic \"Getting Started with Python\" --output-dir docs/tutorials\ndoc-gen --topic \"Python API Reference\" --output-dir docs/references  \ndoc-gen --topic \"Python Best Practices\" --output-dir docs/guides\n</code></pre>"},{"location":"examples/basic/#custom-file-naming","title":"Custom File Naming","text":"<p>The tool automatically generates descriptive filenames:</p> <pre><code># Topic: \"Python Machine Learning\"\n# Output: python_machine_learning_gpt4omini_temp03.html\n\n# Topic: \"SLURM Job Arrays\" \n# Output: slurm_job_arrays_gpt4omini_temp03.html\n\n# With multiple runs:\n# Output: topic_name_model_tempX_v1.html, topic_name_model_tempX_v2.html, etc.\n</code></pre>"},{"location":"examples/basic/#configuration-examples","title":"\ud83c\udf9b\ufe0f Configuration Examples","text":""},{"location":"examples/basic/#custom-prompt-templates","title":"Custom Prompt Templates","text":"<pre><code># Use Markdown output format\ndoc-gen --topic \"GitHub Documentation\" \\\n  --prompt-yaml prompts/generator/markdown.yaml \\\n  --output-dir ./markdown-docs\n\n# Use API documentation template\ndoc-gen --topic \"REST API Guide\" \\\n  --prompt-yaml prompts/generator/api-docs.yaml\n</code></pre>"},{"location":"examples/basic/#custom-terminology","title":"Custom Terminology","text":"<pre><code># Use custom HPC modules and terminology\ndoc-gen --topic \"Specialized Computing\" \\\n  --terminology-path ./config/custom-terminology.yaml \\\n  --output-dir ./custom-docs\n</code></pre>"},{"location":"examples/basic/#quality-and-analysis","title":"\ud83d\udd0d Quality and Analysis","text":""},{"location":"examples/basic/#basic-analysis","title":"Basic Analysis","text":"<pre><code># Generate with document analysis\ndoc-gen --topic \"Important Documentation\" --analyze\n\n# Creates additional files:\n# - topic_name_analysis_report.md (structural analysis)\n# - Section scores and recommendations\n</code></pre>"},{"location":"examples/basic/#full-quality-pipeline","title":"Full Quality Pipeline","text":"<pre><code># Complete quality evaluation\ndoc-gen --topic \"Critical Guide\" \\\n  --runs 3 \\\n  --analyze \\\n  --quality-eval \\\n  --verbose\n\n# Creates:\n# - Multiple documentation variants\n# - Analysis report with scores\n# - GPT quality evaluation report\n# - Detailed logging output\n</code></pre>"},{"location":"examples/basic/#common-workflows","title":"\ud83d\udcca Common Workflows","text":""},{"location":"examples/basic/#research-documentation-workflow","title":"Research Documentation Workflow","text":"<pre><code># 1. Generate methodology documentation\ndoc-gen --topic \"Computational Biology Pipeline\" \\\n  --output-dir research/methods \\\n  --model gpt-4 \\\n  --temperature 0.2\n\n# 2. Create software documentation  \ndoc-gen --topic \"Bioinformatics Tools Setup\" \\\n  --output-dir research/software \\\n  --runs 2\n\n# 3. Generate troubleshooting guide\ndoc-gen --topic \"Common Pipeline Errors\" \\\n  --output-dir research/troubleshooting\n</code></pre>"},{"location":"examples/basic/#software-project-workflow","title":"Software Project Workflow","text":"<pre><code># 1. API documentation\ndoc-gen --topic \"REST API Reference\" \\\n  --prompt-yaml prompts/generator/api-docs.yaml \\\n  --output-dir docs/api\n\n# 2. Installation guide\ndoc-gen --topic \"Development Environment Setup\" \\\n  --output-dir docs/setup \\\n  --runs 2 \\\n  --analyze\n\n# 3. User tutorials\ndoc-gen --topic \"Getting Started Tutorial\" \\\n  --output-dir docs/tutorials \\\n  --temperature 0.4\n</code></pre>"},{"location":"examples/basic/#hpc-user-support-workflow","title":"HPC User Support Workflow","text":"<pre><code># 1. New user onboarding\ndoc-gen --topic \"Cluster Access and Setup\" \\\n  --output-dir support/onboarding\n\n# 2. Software tutorials\ndoc-gen --topic \"SLURM Job Submission Guide\" \\\n  --output-dir support/tutorials \\\n  --runs 2\n\n# 3. Troubleshooting documentation\ndoc-gen --topic \"Common SLURM Issues\" \\\n  --output-dir support/troubleshooting \\\n  --analyze \\\n  --quality-eval\n</code></pre>"},{"location":"examples/basic/#topic-formulation-tips","title":"\ud83c\udfaf Topic Formulation Tips","text":""},{"location":"examples/basic/#effective-topics","title":"Effective Topics","text":"<pre><code># \u2705 Good: Specific and descriptive\ndoc-gen --topic \"Python pandas DataFrame operations for time series analysis\"\ndoc-gen --topic \"SLURM job arrays for Monte Carlo simulations\"\ndoc-gen --topic \"GPU-accelerated machine learning with PyTorch\"\n\n# \u274c Poor: Too vague or generic\ndoc-gen --topic \"Python\"\ndoc-gen --topic \"Help\"\ndoc-gen --topic \"Programming\"\n</code></pre>"},{"location":"examples/basic/#context-rich-topics","title":"Context-Rich Topics","text":"<pre><code># Include relevant context for better results\ndoc-gen --topic \"Setting up Jupyter notebooks on FASRC cluster with conda environments\"\n\n# Specify use cases\ndoc-gen --topic \"Parallel processing with MPI for computational chemistry simulations\"\n\n# Include technology stack\ndoc-gen --topic \"Django web application deployment with PostgreSQL and Redis\"\n</code></pre>"},{"location":"examples/basic/#common-issues-and-solutions","title":"\ud83d\udea8 Common Issues and Solutions","text":""},{"location":"examples/basic/#no-module-recommendations","title":"No Module Recommendations","text":"<pre><code># Issue: Generated documentation lacks module suggestions\n# Solution: Check plugin status\ndoc-gen --list-plugins\n\n# Ensure terminology.yaml has HPC modules\nhead -20 terminology.yaml\n\n# Test plugin directly\npython -c \"\nfrom doc_generator.plugins.modules import ModuleRecommender\nimport yaml\nwith open('terminology.yaml') as f:\n    term = yaml.safe_load(f)\nrec = ModuleRecommender(terminology=term)\nprint(rec.get_recommendations('Python'))\n\"\n</code></pre>"},{"location":"examples/basic/#low-quality-output","title":"Low Quality Output","text":"<pre><code># Issue: Generated documentation is too generic or low quality\n# Solutions:\n\n# 1. Use more specific topics\ndoc-gen --topic \"Python scikit-learn model training for image classification\"\n\n# 2. Use better model\ndoc-gen --topic \"Same Topic\" --model gpt-4\n\n# 3. Lower temperature for more focused output\ndoc-gen --topic \"Same Topic\" --temperature 0.1\n\n# 4. Generate multiple variants and compare\ndoc-gen --topic \"Same Topic\" --runs 5 --analyze\n</code></pre>"},{"location":"examples/basic/#api-rate-limiting","title":"API Rate Limiting","text":"<pre><code># Issue: OpenAI API rate limits\n# Solutions:\n\n# 1. Add delays between generations\ndoc-gen --topic \"Topic 1\"\nsleep 5\ndoc-gen --topic \"Topic 2\"\n\n# 2. Use cheaper model for testing\ndoc-gen --topic \"Test Topic\" --model gpt-3.5-turbo\n\n# 3. Reduce number of runs during development\ndoc-gen --topic \"Dev Topic\" --runs 1\n</code></pre> <p>Ready for more advanced usage? Check out the Advanced Workflows examples or learn about Plugin Examples!</p>"},{"location":"examples/plugins/","title":"Plugin Examples","text":"<p>This page provides practical examples of creating, testing, and using plugins with doc-generator.</p>"},{"location":"examples/plugins/#built-in-plugin-usage","title":"\ud83d\udd0c Built-in Plugin Usage","text":""},{"location":"examples/plugins/#modulerecommender-in-action","title":"ModuleRecommender in Action","text":"<p>The built-in ModuleRecommender demonstrates how plugins enhance documentation:</p> <pre><code># Generate documentation with module recommendations\ndoc-gen --topic \"Python Machine Learning with GPU acceleration\"\n</code></pre> <p>Generated content includes: <pre><code>&lt;h2&gt;Installation&lt;/h2&gt;\n&lt;p&gt;To get started with Python machine learning on the cluster, load the required modules:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;module load python/3.12.8-fasrc01\nmodule load gcc/12.2.0-fasrc01  \nmodule load cuda/12.9.1-fasrc01\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;These modules provide:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;python/3.12.8-fasrc01&lt;/strong&gt;: Python 3.12 with Anaconda distribution&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;gcc/12.2.0-fasrc01&lt;/strong&gt;: GNU Compiler Collection for building extensions&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;cuda/12.9.1-fasrc01&lt;/strong&gt;: NVIDIA CUDA toolkit for GPU acceleration&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre></p>"},{"location":"examples/plugins/#plugin-management","title":"Plugin Management","text":"<pre><code># View all available plugins\ndoc-gen --list-plugins\n\n# Disable the modules plugin\ndoc-gen --topic \"General Topic\" --disable-plugins modules\n\n# Enable only specific plugins (useful when you have multiple)\ndoc-gen --topic \"Data Science\" --enable-only modules,datasets\n</code></pre>"},{"location":"examples/plugins/#creating-simple-plugins","title":"\ud83d\udee0\ufe0f Creating Simple Plugins","text":""},{"location":"examples/plugins/#1-basic-resource-recommender","title":"1. Basic Resource Recommender","text":"<pre><code># my_plugins/resource_recommender.py\nfrom typing import List, Dict, Optional\nfrom doc_generator.plugins.base import RecommendationEngine\n\nclass ResourceRecommender(RecommendationEngine):\n    \"\"\"Recommends online resources and documentation links.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n\n        # Define resource database\n        self.resources = {\n            'python': [\n                {\n                    'title': 'Python Official Documentation',\n                    'url': 'https://docs.python.org/',\n                    'description': 'Comprehensive Python documentation',\n                    'type': 'documentation'\n                },\n                {\n                    'title': 'Real Python Tutorials',\n                    'url': 'https://realpython.com/',\n                    'description': 'Practical Python tutorials and guides',\n                    'type': 'tutorial'\n                }\n            ],\n            'machine learning': [\n                {\n                    'title': 'scikit-learn User Guide',\n                    'url': 'https://scikit-learn.org/stable/user_guide.html',\n                    'description': 'Machine learning library documentation',\n                    'type': 'documentation'\n                }\n            ]\n        }\n\n    def get_name(self) -&gt; str:\n        return \"resources\"\n\n    def get_supported_types(self) -&gt; List[str]:\n        return [\"documentation\", \"tutorials\", \"references\"]\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Find relevant resources for the topic.\"\"\"\n        topic_lower = topic.lower()\n        recommendations = []\n\n        for category, resources in self.resources.items():\n            if category in topic_lower:\n                for resource in resources:\n                    recommendation = resource.copy()\n                    recommendation['relevance_score'] = self._calculate_relevance(topic_lower, category)\n                    recommendations.append(recommendation)\n\n        return sorted(recommendations, key=lambda x: x['relevance_score'], reverse=True)\n\n    def _calculate_relevance(self, topic: str, category: str) -&gt; float:\n        \"\"\"Calculate relevance score based on keyword matches.\"\"\"\n        # Simple keyword matching\n        words = topic.split()\n        category_words = category.split()\n\n        matches = sum(1 for word in words if word in category_words)\n        return min(10.0, matches * 3.0 + 5.0)  # Base score of 5, bonus for matches\n\n# Test the plugin\nif __name__ == \"__main__\":\n    plugin = ResourceRecommender()\n    results = plugin.get_recommendations(\"Python machine learning tutorial\")\n\n    for rec in results:\n        print(f\"Title: {rec['title']}\")\n        print(f\"URL: {rec['url']}\")\n        print(f\"Score: {rec['relevance_score']}\")\n        print(\"---\")\n</code></pre>"},{"location":"examples/plugins/#2-code-template-recommender","title":"2. Code Template Recommender","text":"<pre><code># my_plugins/template_recommender.py\nfrom typing import List, Dict, Optional\nfrom doc_generator.plugins.base import RecommendationEngine\n\nclass TemplateRecommender(RecommendationEngine):\n    \"\"\"Recommends code templates and boilerplate for different languages.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n\n        self.templates = {\n            'python': {\n                'data_analysis': {\n                    'name': 'Python Data Analysis Template',\n                    'description': 'Template for data analysis with pandas and matplotlib',\n                    'code': '''import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load data\ndf = pd.read_csv('data.csv')\n\n# Basic analysis\nprint(df.describe())\nprint(df.info())\n\n# Visualization\nplt.figure(figsize=(10, 6))\ndf.plot()\nplt.show()''',\n                    'language': 'python'\n                },\n                'machine_learning': {\n                    'name': 'scikit-learn ML Template',\n                    'description': 'Basic machine learning workflow template',\n                    'code': '''from sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report\n\n# Prepare data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Train model\nmodel = RandomForestClassifier()\nmodel.fit(X_train, y_train)\n\n# Evaluate\npredictions = model.predict(X_test)\nprint(classification_report(y_test, predictions))''',\n                    'language': 'python'\n                }\n            },\n            'slurm': {\n                'basic_job': {\n                    'name': 'Basic SLURM Job Script',\n                    'description': 'Template for submitting jobs to SLURM scheduler',\n                    'code': '''#!/bin/bash\n#SBATCH -J my_job\n#SBATCH -p shared\n#SBATCH -t 1:00:00\n#SBATCH --mem=4G\n#SBATCH -o output_%j.out\n#SBATCH -e error_%j.err\n\n# Load required modules  \nmodule load python/3.12.8-fasrc01\n\n# Run your code\npython my_script.py''',\n                    'language': 'bash'\n                }\n            }\n        }\n\n    def get_name(self) -&gt; str:\n        return \"templates\"\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Find relevant code templates.\"\"\"\n        topic_lower = topic.lower()\n        recommendations = []\n\n        for language, templates in self.templates.items():\n            if language in topic_lower:\n                for template_key, template in templates.items():\n                    if any(keyword in topic_lower for keyword in template_key.split('_')):\n                        recommendation = {\n                            'title': template['name'],\n                            'description': template['description'],\n                            'code': template['code'],\n                            'language': template['language'],\n                            'type': 'code_template',\n                            'relevance_score': self._calculate_template_score(topic_lower, template_key)\n                        }\n                        recommendations.append(recommendation)\n\n        return sorted(recommendations, key=lambda x: x['relevance_score'], reverse=True)\n\n    def _calculate_template_score(self, topic: str, template_key: str) -&gt; float:\n        \"\"\"Calculate relevance score for templates.\"\"\"\n        template_words = template_key.replace('_', ' ').split()\n        topic_words = topic.split()\n\n        matches = sum(1 for word in template_words if word in topic_words)\n        return matches * 2.5 + 5.0\n\n    def get_formatted_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; str:\n        \"\"\"Format templates for documentation.\"\"\"\n        templates = self.get_recommendations(topic, context)\n\n        if not templates:\n            return \"\"\n\n        formatted = \"\\n## Code Templates\\n\\n\"\n        for template in templates:\n            formatted += f\"### {template['title']}\\n\\n\"\n            formatted += f\"{template['description']}\\n\\n\"\n            formatted += f\"```{template['language']}\\n{template['code']}\\n```\\n\\n\"\n\n        return formatted\n</code></pre>"},{"location":"examples/plugins/#3-testing-your-plugins","title":"3. Testing Your Plugins","text":"<pre><code># tests/test_my_plugins.py\nimport pytest\nfrom my_plugins.resource_recommender import ResourceRecommender\nfrom my_plugins.template_recommender import TemplateRecommender\n\nclass TestResourceRecommender:\n    def test_basic_functionality(self):\n        plugin = ResourceRecommender()\n\n        assert plugin.get_name() == \"resources\"\n        assert \"documentation\" in plugin.get_supported_types()\n\n    def test_python_recommendations(self):\n        plugin = ResourceRecommender()\n        results = plugin.get_recommendations(\"Python programming tutorial\")\n\n        assert len(results) &gt; 0\n        assert any(\"Python\" in rec['title'] for rec in results)\n\n        for rec in results:\n            assert 'title' in rec\n            assert 'url' in rec\n            assert 'relevance_score' in rec\n            assert isinstance(rec['relevance_score'], (int, float))\n\n    def test_empty_topic(self):\n        plugin = ResourceRecommender()\n        results = plugin.get_recommendations(\"\")\n\n        assert isinstance(results, list)\n\nclass TestTemplateRecommender:\n    def test_template_retrieval(self):\n        plugin = TemplateRecommender()\n        results = plugin.get_recommendations(\"Python data analysis\")\n\n        assert len(results) &gt; 0\n        template = results[0]\n\n        assert 'code' in template\n        assert 'language' in template\n        assert template['language'] == 'python'\n        assert 'import pandas' in template['code']\n\n    def test_slurm_templates(self):\n        plugin = TemplateRecommender()\n        results = plugin.get_recommendations(\"SLURM job submission\")\n\n        assert len(results) &gt; 0\n        template = results[0]\n\n        assert template['language'] == 'bash'\n        assert '#SBATCH' in template['code']\n\n    def test_formatted_output(self):\n        plugin = TemplateRecommender()\n        formatted = plugin.get_formatted_recommendations(\"Python machine learning\")\n\n        assert \"## Code Templates\" in formatted\n        assert \"```python\" in formatted\n</code></pre>"},{"location":"examples/plugins/#external-api-plugins","title":"\ud83c\udf10 External API Plugins","text":""},{"location":"examples/plugins/#github-repository-recommender","title":"GitHub Repository Recommender","text":"<pre><code># my_plugins/github_recommender.py\nimport requests\nfrom typing import List, Dict, Optional\nfrom doc_generator.plugins.base import RecommendationEngine\n\nclass GitHubRecommender(RecommendationEngine):\n    \"\"\"Recommends relevant GitHub repositories.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n        self.api_url = \"https://api.github.com/search/repositories\"\n\n    def get_name(self) -&gt; str:\n        return \"github\"\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Search GitHub for relevant repositories.\"\"\"\n        try:\n            # Extract keywords for search\n            keywords = self._extract_keywords(topic)\n            query = \" \".join(keywords[:3])  # Limit to top 3 keywords\n\n            params = {\n                'q': f\"{query} language:python\",\n                'sort': 'stars',\n                'order': 'desc',\n                'per_page': 5\n            }\n\n            response = requests.get(self.api_url, params=params, timeout=10)\n            response.raise_for_status()\n\n            data = response.json()\n            repositories = []\n\n            for repo in data.get('items', []):\n                repository = {\n                    'title': repo['full_name'],\n                    'description': repo['description'] or 'No description available',\n                    'url': repo['html_url'],\n                    'stars': repo['stargazers_count'],\n                    'language': repo['language'],\n                    'relevance_score': self._calculate_github_score(repo, keywords),\n                    'type': 'repository'\n                }\n                repositories.append(repository)\n\n            return repositories\n\n        except Exception as e:\n            self.logger.warning(f\"GitHub API error: {e}\")\n            return []\n\n    def _extract_keywords(self, topic: str) -&gt; List[str]:\n        \"\"\"Extract searchable keywords from topic.\"\"\"\n        import re\n        words = re.findall(r'\\w+', topic.lower())\n        stop_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'with'}\n        return [word for word in words if word not in stop_words and len(word) &gt; 2]\n\n    def _calculate_github_score(self, repo: dict, keywords: List[str]) -&gt; float:\n        \"\"\"Calculate relevance score for GitHub repository.\"\"\"\n        score = 0.0\n\n        # Star-based score (0-5 points)\n        stars = repo['stargazers_count']\n        star_score = min(5.0, stars / 1000)\n        score += star_score\n\n        # Keyword matching in name and description\n        text = f\"{repo['name']} {repo.get('description', '')}\".lower()\n        keyword_score = sum(2.0 for keyword in keywords if keyword in text)\n        score += keyword_score\n\n        return min(10.0, score)\n</code></pre>"},{"location":"examples/plugins/#paper-recommender-arxiv","title":"Paper Recommender (arXiv)","text":"<pre><code># my_plugins/arxiv_recommender.py\nimport requests\nimport xml.etree.ElementTree as ET\nfrom typing import List, Dict, Optional\nfrom doc_generator.plugins.base import RecommendationEngine\n\nclass ArxivRecommender(RecommendationEngine):\n    \"\"\"Recommends academic papers from arXiv.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n        self.api_url = \"http://export.arxiv.org/api/query\"\n\n    def get_name(self) -&gt; str:\n        return \"papers\"\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Search arXiv for relevant papers.\"\"\"\n        try:\n            # Build search query\n            keywords = self._extract_keywords(topic)\n            query = \" AND \".join(keywords[:3])\n\n            params = {\n                'search_query': f'all:{query}',\n                'start': 0,\n                'max_results': 5,\n                'sortBy': 'relevance',\n                'sortOrder': 'descending'\n            }\n\n            response = requests.get(self.api_url, params=params, timeout=15)\n            response.raise_for_status()\n\n            # Parse XML response\n            root = ET.fromstring(response.content)\n\n            papers = []\n            for entry in root.findall('{http://www.w3.org/2005/Atom}entry'):\n                paper = self._parse_arxiv_entry(entry, keywords)\n                if paper:\n                    papers.append(paper)\n\n            return papers\n\n        except Exception as e:\n            self.logger.warning(f\"arXiv API error: {e}\")\n            return []\n\n    def _parse_arxiv_entry(self, entry, keywords: List[str]) -&gt; Dict:\n        \"\"\"Parse a single arXiv entry.\"\"\"\n        ns = {'atom': 'http://www.w3.org/2005/Atom'}\n\n        title = entry.find('atom:title', ns)\n        summary = entry.find('atom:summary', ns)\n        link = entry.find('atom:id', ns)\n        published = entry.find('atom:published', ns)\n\n        # Get authors\n        authors = []\n        for author in entry.findall('atom:author', ns):\n            name = author.find('atom:name', ns)\n            if name is not None:\n                authors.append(name.text)\n\n        return {\n            'title': title.text.strip() if title is not None else 'Unknown Title',\n            'description': summary.text.strip()[:200] + '...' if summary is not None else '',\n            'url': link.text if link is not None else '',\n            'authors': ', '.join(authors[:3]),\n            'published': published.text[:10] if published is not None else '',\n            'relevance_score': self._calculate_paper_score(title.text if title else '', keywords),\n            'type': 'academic_paper'\n        }\n\n    def _calculate_paper_score(self, title: str, keywords: List[str]) -&gt; float:\n        \"\"\"Calculate relevance score for papers.\"\"\"\n        title_lower = title.lower()\n        score = 5.0  # Base score\n\n        for keyword in keywords:\n            if keyword in title_lower:\n                score += 1.5\n\n        return min(10.0, score)\n\n    def _extract_keywords(self, topic: str) -&gt; List[str]:\n        \"\"\"Extract keywords suitable for academic search.\"\"\"\n        import re\n        words = re.findall(r'\\w+', topic.lower())\n\n        # Filter for more academic/technical terms\n        stop_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'with', 'using', 'how', 'what'}\n        technical_words = [word for word in words if word not in stop_words and len(word) &gt; 3]\n\n        return technical_words[:5]  # Limit to avoid overly complex queries\n</code></pre>"},{"location":"examples/plugins/#plugin-integration-examples","title":"\ud83d\udd27 Plugin Integration Examples","text":""},{"location":"examples/plugins/#plugin-package-structure","title":"Plugin Package Structure","text":"<pre><code>my-doc-plugins/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_doc_plugins/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 resource_recommender.py\n\u2502       \u251c\u2500\u2500 template_recommender.py\n\u2502       \u251c\u2500\u2500 github_recommender.py\n\u2502       \u2514\u2500\u2500 arxiv_recommender.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_resource_recommender.py\n\u2502   \u251c\u2500\u2500 test_template_recommender.py\n\u2502   \u2514\u2500\u2500 test_integration.py\n\u2514\u2500\u2500 examples/\n    \u2514\u2500\u2500 usage_examples.py\n</code></pre>"},{"location":"examples/plugins/#pyprojecttoml-for-plugin-package","title":"pyproject.toml for Plugin Package","text":"<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-doc-plugins\"\nversion = \"0.1.0\"\ndescription = \"Additional plugins for doc-generator\"\nauthors = [{name = \"Your Name\", email = \"your.email@example.com\"}]\nreadme = \"README.md\"\nlicense = {text = \"MIT\"}\nkeywords = [\"documentation\", \"plugins\", \"recommendations\"]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n]\nrequires-python = \"&gt;=3.8\"\ndependencies = [\n    \"doc-generator&gt;=1.1.0\",\n    \"requests&gt;=2.28.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0.0\",\n    \"pytest-cov&gt;=4.0.0\",\n    \"black&gt;=22.0.0\",\n    \"flake8&gt;=5.0.0\",\n]\n\n# Register plugins with doc-generator\n[project.entry-points.\"doc_generator.plugins\"]\nresources = \"my_doc_plugins.resource_recommender:ResourceRecommender\"\ntemplates = \"my_doc_plugins.template_recommender:TemplateRecommender\"\ngithub = \"my_doc_plugins.github_recommender:GitHubRecommender\"\npapers = \"my_doc_plugins.arxiv_recommender:ArxivRecommender\"\n\n[project.urls]\nHomepage = \"https://github.com/yourusername/my-doc-plugins\"\nRepository = \"https://github.com/yourusername/my-doc-plugins\"\n</code></pre>"},{"location":"examples/plugins/#installation-and-usage","title":"Installation and Usage","text":"<pre><code># Install your plugin package\npip install -e ./my-doc-plugins\n\n# Verify plugins are discovered\ndoc-gen --list-plugins\n\n# Use with documentation generation\ndoc-gen --topic \"Python machine learning research\" --output-dir ./research-docs\n\n# Generated documentation will now include:\n# - HPC module recommendations (built-in)\n# - Online resource links (your resource plugin)\n# - Code templates (your template plugin)\n# - GitHub repository suggestions (your github plugin)\n# - Academic paper references (your arxiv plugin)\n</code></pre>"},{"location":"examples/plugins/#advanced-plugin-usage","title":"Advanced Plugin Usage","text":"<pre><code># Enable only specific plugins\ndoc-gen --topic \"Academic Research\" --enable-only modules,papers,resources\n\n# Disable external API plugins for faster generation\ndoc-gen --topic \"Quick Test\" --disable-plugins github,papers\n\n# Use plugins with custom configuration\nexport GITHUB_PLUGIN_LANGUAGE=python\nexport ARXIV_PLUGIN_CATEGORIES=\"cs.LG,cs.AI\"\ndoc-gen --topic \"Machine Learning\" --verbose\n</code></pre>"},{"location":"examples/plugins/#plugin-testing-strategies","title":"\ud83e\uddea Plugin Testing Strategies","text":""},{"location":"examples/plugins/#integration-testing","title":"Integration Testing","text":"<pre><code># tests/test_plugin_integration.py\nimport pytest\nfrom doc_generator import DocumentationGenerator\nfrom my_doc_plugins.github_recommender import GitHubRecommender\n\ndef test_plugin_integration_with_generator():\n    \"\"\"Test that custom plugins work with DocumentationGenerator.\"\"\"\n\n    # Mock the plugin discovery to include our plugin\n    from unittest.mock import patch, Mock\n\n    mock_entry_point = Mock()\n    mock_entry_point.name = \"github\"\n    mock_entry_point.load.return_value = GitHubRecommender\n\n    with patch('doc_generator.plugin_manager.entry_points') as mock_eps:\n        mock_eps.return_value = [mock_entry_point]\n\n        # Create generator with our plugin\n        generator = DocumentationGenerator()\n\n        # Plugin should be loaded\n        assert \"github\" in generator.plugin_manager.engines\n\n        # Test that plugin contributes to context\n        # (Note: This requires mocking the GitHub API)\n        with patch('requests.get') as mock_get:\n            mock_response = Mock()\n            mock_response.json.return_value = {\n                'items': [{\n                    'full_name': 'test/repo',\n                    'description': 'Test repository',\n                    'html_url': 'https://github.com/test/repo',\n                    'stargazers_count': 100,\n                    'language': 'Python'\n                }]\n            }\n            mock_get.return_value = mock_response\n\n            context = generator._build_terminology_context(\"Python testing\")\n            # Verify GitHub recommendations are included\n            assert \"test/repo\" in str(context)\n</code></pre>"},{"location":"examples/plugins/#performance-testing","title":"Performance Testing","text":"<pre><code># tests/test_plugin_performance.py\nimport time\nimport pytest\nfrom my_doc_plugins.github_recommender import GitHubRecommender\n\ndef test_github_plugin_performance():\n    \"\"\"Test that GitHub plugin responds within reasonable time.\"\"\"\n    plugin = GitHubRecommender()\n\n    start_time = time.time()\n    results = plugin.get_recommendations(\"Python machine learning\")\n    end_time = time.time()\n\n    # Should complete within 15 seconds (GitHub API timeout + processing)\n    assert (end_time - start_time) &lt; 15.0\n\n    # Should return some results (assuming internet connection)\n    assert isinstance(results, list)\n\ndef test_plugin_error_handling():\n    \"\"\"Test that plugins handle API errors gracefully.\"\"\"\n    plugin = GitHubRecommender()\n\n    # Mock network error\n    with patch('requests.get') as mock_get:\n        mock_get.side_effect = requests.RequestException(\"Network error\")\n\n        # Should not crash\n        results = plugin.get_recommendations(\"Any topic\")\n\n        # Should return empty list\n        assert results == []\n</code></pre> <p>These examples show how to create powerful, real-world plugins that extend doc-generator's capabilities. Start with simple plugins and gradually add more sophisticated features as needed. For more details, see the comprehensive Creating Plugins Guide.</p>"},{"location":"examples/troubleshooting/","title":"Troubleshooting","text":"<p>This guide helps you diagnose and resolve common issues with doc-generator.</p>"},{"location":"examples/troubleshooting/#common-issues","title":"\ud83d\udea8 Common Issues","text":""},{"location":"examples/troubleshooting/#installation-problems","title":"Installation Problems","text":""},{"location":"examples/troubleshooting/#issue-modulenotfounderror-no-module-named-doc_generator","title":"Issue: <code>ModuleNotFoundError: No module named 'doc_generator'</code>","text":"<p>Symptoms: <pre><code>$ doc-gen --help\nTraceback (most recent call last):\n  File \"/usr/local/bin/doc-gen\", line 5, in &lt;module&gt;\n    from doc_generator.cli import main\nModuleNotFoundError: No module named 'doc_generator'\n</code></pre></p> <p>Solutions: <pre><code># 1. Verify you're in the correct directory\ncd /path/to/doc-fun\n\n# 2. Check if package is installed\npip list | grep doc-generator\n\n# 3. Reinstall in editable mode\npip uninstall doc-generator  # if installed\npip install -e .\n\n# 4. Verify installation\npython -c \"import doc_generator; print(doc_generator.__version__)\"\n</code></pre></p>"},{"location":"examples/troubleshooting/#issue-importerror-no-module-named-openai","title":"Issue: <code>ImportError: No module named 'openai'</code>","text":"<p>Symptoms: <pre><code>ImportError: No module named 'openai'\n</code></pre></p> <p>Solutions: <pre><code># 1. Install missing dependencies\npip install openai&gt;=1.0.0\n\n# 2. Or reinstall with all dependencies\npip install -e \".[dev]\"\n\n# 3. Check requirements\npip check\n</code></pre></p>"},{"location":"examples/troubleshooting/#api-and-authentication-issues","title":"API and Authentication Issues","text":""},{"location":"examples/troubleshooting/#issue-openai-api-key-not-found","title":"Issue: <code>OpenAI API key not found</code>","text":"<p>Symptoms: <pre><code>Error: OpenAI API key not found. Please set OPENAI_API_KEY environment variable.\n</code></pre></p> <p>Solutions: <pre><code># 1. Check if .env file exists\nls -la .env\n\n# 2. Create .env file\necho \"OPENAI_API_KEY=your-api-key-here\" &gt; .env\n\n# 3. Set environment variable directly\nexport OPENAI_API_KEY=\"your-api-key-here\"\n\n# 4. Verify API key is loaded\npython -c \"import os; print('Key found' if os.getenv('OPENAI_API_KEY') else 'Key missing')\"\n</code></pre></p>"},{"location":"examples/troubleshooting/#issue-openai-api-error-rate-limit-exceeded","title":"Issue: <code>OpenAI API Error: Rate limit exceeded</code>","text":"<p>Symptoms: <pre><code>OpenAI API Error: Rate limit exceeded for requests per minute. Please try again later.\n</code></pre></p> <p>Solutions: <pre><code># 1. Wait and retry (rate limits reset after time)\nsleep 60\ndoc-gen --topic \"Your Topic\"\n\n# 2. Use a slower approach with delays\ndoc-gen --topic \"Topic 1\"\nsleep 10\ndoc-gen --topic \"Topic 2\"\n\n# 3. Use a cheaper model for testing\ndoc-gen --topic \"Test Topic\" --model gpt-3.5-turbo\n\n# 4. Reduce number of runs\ndoc-gen --topic \"Your Topic\" --runs 1\n</code></pre></p>"},{"location":"examples/troubleshooting/#issue-openai-api-error-invalid-api-key","title":"Issue: <code>OpenAI API Error: Invalid API key</code>","text":"<p>Symptoms: <pre><code>OpenAI API Error: Incorrect API key provided\n</code></pre></p> <p>Solutions: <pre><code># 1. Verify API key format (should start with sk-)\necho $OPENAI_API_KEY\n\n# 2. Check OpenAI dashboard for valid keys\n# Visit: https://platform.openai.com/api-keys\n\n# 3. Generate new API key if needed\n# 4. Update .env file with correct key\n</code></pre></p>"},{"location":"examples/troubleshooting/#plugin-issues","title":"Plugin Issues","text":""},{"location":"examples/troubleshooting/#issue-no-plugin-recommendations-appearing","title":"Issue: No Plugin Recommendations Appearing","text":"<p>Symptoms: - Generated documentation lacks HPC module suggestions - No plugin-specific content in output</p> <p>Diagnosis: <pre><code># 1. Check if plugins are loaded\ndoc-gen --list-plugins\n\n# Expected output should show modules plugin:\n# Plugin: modules\n#   Class: ModuleRecommender\n#   Enabled: True\n</code></pre></p> <p>Solutions: <pre><code># 1. Verify terminology.yaml has HPC modules\nhead -20 terminology.yaml\n\n# Should contain:\n# hpc_modules:\n#   - name: \"python/3.12.8-fasrc01\"\n#     description: \"Python 3.12...\"\n\n# 2. Test plugin directly\npython -c \"\nfrom doc_generator.plugins.modules import ModuleRecommender\nimport yaml\nwith open('terminology.yaml') as f:\n    term = yaml.safe_load(f)\nrec = ModuleRecommender(terminology=term) \nprint(rec.get_recommendations('Python'))\n\"\n\n# 3. Check plugin manager\npython -c \"\nfrom doc_generator.plugin_manager import PluginManager\nimport yaml\nwith open('terminology.yaml') as f:\n    term = yaml.safe_load(f)\npm = PluginManager(terminology=term)\npm.load_plugins()\nprint(list(pm.engines.keys()))\n\"\n</code></pre></p>"},{"location":"examples/troubleshooting/#issue-plugin-import-errors","title":"Issue: Plugin Import Errors","text":"<p>Symptoms: <pre><code>WARNING: Failed to load plugin 'my_plugin': No module named 'my_plugin'\n</code></pre></p> <p>Solutions: <pre><code># 1. Verify plugin package is installed\npip list | grep my-plugin\n\n# 2. Check entry points registration\npython -c \"\nfrom importlib.metadata import entry_points\neps = entry_points(group='doc_generator.plugins')\nfor ep in eps:\n    print(f'{ep.name}: {ep.value}')\n\"\n\n# 3. Reinstall plugin package\npip install -e /path/to/my-plugin-package\n</code></pre></p>"},{"location":"examples/troubleshooting/#generation-quality-issues","title":"Generation Quality Issues","text":""},{"location":"examples/troubleshooting/#issue-generated-documentation-is-too-generic","title":"Issue: Generated Documentation is Too Generic","text":"<p>Symptoms: - Output lacks specific details - Missing relevant technical information - Generic boilerplate content</p> <p>Solutions: <pre><code># 1. Use more specific topics\n# \u274c Poor\ndoc-gen --topic \"Python\"\n\n# \u2705 Better  \ndoc-gen --topic \"Python pandas DataFrame operations for time series analysis\"\n\n# 2. Use better model\ndoc-gen --topic \"Specific Topic\" --model gpt-4\n\n# 3. Lower temperature for more focused output\ndoc-gen --topic \"Technical Documentation\" --temperature 0.1\n\n# 4. Generate multiple variants and compare\ndoc-gen --topic \"Important Topic\" --runs 5 --analyze\n</code></pre></p>"},{"location":"examples/troubleshooting/#issue-missing-hpc-specific-content","title":"Issue: Missing HPC-Specific Content","text":"<p>Symptoms: - No module load commands - Generic installation instructions - Missing cluster-specific information</p> <p>Solutions: <pre><code># 1. Ensure terminology.yaml is comprehensive\ncat terminology.yaml | grep -A 5 hpc_modules\n\n# 2. Use HPC-specific topics\ndoc-gen --topic \"Running Python machine learning on SLURM cluster\"\n\n# 3. Check plugin status\ndoc-gen --list-plugins | grep modules\n\n# 4. Test with verbose output\ndoc-gen --topic \"HPC Topic\" --verbose\n</code></pre></p>"},{"location":"examples/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"examples/troubleshooting/#issue-very-slow-generation","title":"Issue: Very Slow Generation","text":"<p>Symptoms: - Long wait times (&gt;5 minutes per generation) - Timeouts or hanging</p> <p>Diagnosis: <pre><code># Run with verbose output to see where it's stuck\ndoc-gen --topic \"Test Topic\" --verbose\n</code></pre></p> <p>Solutions: <pre><code># 1. Use faster model\ndoc-gen --topic \"Your Topic\" --model gpt-3.5-turbo\n\n# 2. Reduce number of runs\ndoc-gen --topic \"Your Topic\" --runs 1\n\n# 3. Disable external API plugins if you have them\ndoc-gen --topic \"Your Topic\" --disable-plugins github,datasets\n\n# 4. Check internet connection and OpenAI API status\ncurl -I https://api.openai.com/v1/models\n</code></pre></p>"},{"location":"examples/troubleshooting/#issue-high-api-costs","title":"Issue: High API Costs","text":"<p>Symptoms: - Unexpected high charges on OpenAI account - Rapid token consumption</p> <p>Solutions: <pre><code># 1. Use cheaper models for development\ndoc-gen --topic \"Dev Topic\" --model gpt-3.5-turbo\n\n# 2. Reduce runs and temperature\ndoc-gen --topic \"Topic\" --runs 1 --temperature 0.3\n\n# 3. Use more specific topics (reduces token usage)\ndoc-gen --topic \"Very specific technical question\"\n\n# 4. Monitor usage\n# Check OpenAI dashboard regularly\n</code></pre></p>"},{"location":"examples/troubleshooting/#output-and-file-issues","title":"Output and File Issues","text":""},{"location":"examples/troubleshooting/#issue-empty-or-corrupted-output-files","title":"Issue: Empty or Corrupted Output Files","text":"<p>Symptoms: <pre><code># Empty files\n$ ls -la output/\n-rw-r--r-- 1 user staff 0 date topic_file.html\n\n# Or corrupted content\n$ head output/topic_file.html\nError: [object Object]\n</code></pre></p> <p>Solutions: <pre><code># 1. Check for API errors in verbose mode\ndoc-gen --topic \"Test Topic\" --verbose\n\n# 2. Verify output directory permissions\nmkdir -p output\nchmod 755 output\n\n# 3. Test with simple topic\ndoc-gen --topic \"Hello World\" --runs 1\n\n# 4. Check available disk space\ndf -h .\n</code></pre></p>"},{"location":"examples/troubleshooting/#issue-file-permission-errors","title":"Issue: File Permission Errors","text":"<p>Symptoms: <pre><code>PermissionError: [Errno 13] Permission denied: 'output/file.html'\n</code></pre></p> <p>Solutions: <pre><code># 1. Check directory permissions\nls -la output/\n\n# 2. Fix permissions\nchmod 755 output/\nchmod 644 output/*.html\n\n# 3. Use different output directory\ndoc-gen --topic \"Topic\" --output-dir /tmp/doc-test\n\n# 4. Check if files are open in other applications\nlsof output/*.html\n</code></pre></p>"},{"location":"examples/troubleshooting/#debugging-tools","title":"\ud83d\udd27 Debugging Tools","text":""},{"location":"examples/troubleshooting/#verbose-mode","title":"Verbose Mode","text":"<pre><code># Enable detailed logging\ndoc-gen --topic \"Debug Topic\" --verbose\n\n# This shows:\n# - Plugin loading process\n# - API request/response details\n# - File operations\n# - Error stack traces\n</code></pre>"},{"location":"examples/troubleshooting/#dry-run-mode","title":"Dry Run Mode","text":"<pre><code># See what would happen without executing\ndoc-gen --topic \"Test Topic\" --dry-run --verbose\n\n# Shows:\n# - Configuration that would be used\n# - Plugins that would be loaded\n# - Files that would be created\n</code></pre>"},{"location":"examples/troubleshooting/#direct-api-testing","title":"Direct API Testing","text":"<pre><code># test_api.py - Test OpenAI API directly\nimport os\nfrom openai import OpenAI\n\nclient = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))\n\ntry:\n    response = client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[{\"role\": \"user\", \"content\": \"Hello, API test\"}],\n        max_tokens=50\n    )\n    print(\"\u2713 API connection successful\")\n    print(f\"Response: {response.choices[0].message.content}\")\nexcept Exception as e:\n    print(f\"\u2717 API error: {e}\")\n</code></pre>"},{"location":"examples/troubleshooting/#plugin-testing","title":"Plugin Testing","text":"<pre><code># test_plugins.py - Test plugin system\nfrom doc_generator.plugin_manager import PluginManager\nimport yaml\n\ntry:\n    # Load terminology\n    with open('terminology.yaml') as f:\n        terminology = yaml.safe_load(f)\n\n    # Create plugin manager\n    pm = PluginManager(terminology=terminology)\n    pm.load_plugins()\n\n    print(f\"\u2713 Loaded {len(pm.engines)} plugins:\")\n    for name, plugin in pm.engines.items():\n        print(f\"  - {name}: {plugin.__class__.__name__}\")\n\n    # Test recommendations\n    recommendations = pm.get_recommendations(\"Python\")\n    print(f\"\u2713 Got {len(recommendations)} total recommendations\")\n\nexcept Exception as e:\n    print(f\"\u2717 Plugin error: {e}\")\n    import traceback\n    traceback.print_exc()\n</code></pre>"},{"location":"examples/troubleshooting/#system-diagnostics","title":"\ud83d\udcca System Diagnostics","text":""},{"location":"examples/troubleshooting/#environment-check-script","title":"Environment Check Script","text":"<pre><code>#!/bin/bash\n# diagnose.sh - System diagnostic script\n\necho \"=== doc-generator Diagnostics ===\"\necho\n\necho \"1. Python Environment:\"\npython --version\nwhich python\necho\n\necho \"2. Package Installation:\"\npip list | grep -E \"(doc-generator|openai|pyyaml)\"\necho\n\necho \"3. API Key Status:\"\nif [ -z \"$OPENAI_API_KEY\" ]; then \n    echo \"\u274c OPENAI_API_KEY not set\"\nelse \n    echo \"\u2705 OPENAI_API_KEY is set\"\nfi\necho\n\necho \"4. Configuration Files:\"\nfor file in .env terminology.yaml prompts/generator/default.yaml; do\n    if [ -f \"$file\" ]; then\n        echo \"\u2705 $file exists ($(wc -l &lt; \"$file\") lines)\"\n    else\n        echo \"\u274c $file missing\"\n    fi\ndone\necho\n\necho \"5. Output Directory:\"\nif [ -d \"output\" ]; then\n    echo \"\u2705 output/ exists ($(ls output/ | wc -l) files)\"\n    ls -la output/ | head -5\nelse\n    echo \"\u274c output/ directory missing\"\nfi\necho\n\necho \"6. Plugin Status:\"\ndoc-gen --list-plugins 2&gt;&amp;1 | head -10\necho\n\necho \"7. Basic Test:\"\nexport OPENAI_API_KEY=\"${OPENAI_API_KEY:-test-key-for-dry-run}\"\ndoc-gen --topic \"Test Topic\" --dry-run --verbose 2&gt;&amp;1 | tail -5\n</code></pre>"},{"location":"examples/troubleshooting/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code># performance_monitor.py\nimport time\nimport psutil\nimport os\nfrom doc_generator import DocumentationGenerator\n\ndef monitor_generation(topic: str, **kwargs):\n    \"\"\"Monitor system resources during generation.\"\"\"\n\n    # Start monitoring\n    process = psutil.Process(os.getpid())\n    start_time = time.time()\n    start_memory = process.memory_info().rss / 1024 / 1024  # MB\n\n    print(f\"Starting generation: {topic}\")\n    print(f\"Initial memory: {start_memory:.1f} MB\")\n\n    # Generate documentation\n    generator = DocumentationGenerator()\n    results = generator.generate_documentation(query=topic, **kwargs)\n\n    # End monitoring\n    end_time = time.time()\n    end_memory = process.memory_info().rss / 1024 / 1024  # MB\n\n    duration = end_time - start_time\n    memory_used = end_memory - start_memory\n\n    print(f\"Generation completed in {duration:.1f} seconds\")\n    print(f\"Memory used: {memory_used:.1f} MB\")\n    print(f\"Generated {len(results)} variants\")\n\n    return results\n\n# Usage\nresults = monitor_generation(\"Python programming\", runs=2)\n</code></pre>"},{"location":"examples/troubleshooting/#getting-help","title":"\ud83d\udcde Getting Help","text":""},{"location":"examples/troubleshooting/#self-help-checklist","title":"Self-Help Checklist","text":"<p>Before seeking help, try this checklist:</p> <ul> <li> Read error messages carefully</li> <li> Check this troubleshooting guide</li> <li> Run with <code>--verbose</code> flag</li> <li> Test with simple topic</li> <li> Verify API key and internet connection</li> <li> Check file permissions</li> <li> Try with fresh virtual environment</li> </ul>"},{"location":"examples/troubleshooting/#support-resources","title":"Support Resources","text":"<ol> <li>GitHub Issues: Report bugs and get help</li> <li>Documentation: Read all guides</li> <li>Examples: Check usage examples</li> <li>FASRC Support: Contact the original development team</li> </ol>"},{"location":"examples/troubleshooting/#creating-bug-reports","title":"Creating Bug Reports","text":"<p>When reporting issues, include:</p> <pre><code>**Environment:**\n- OS: [e.g., macOS 13.2]\n- Python: [e.g., 3.10.8]\n- doc-generator: [e.g., 1.1.0]\n\n**Command Used:**\n```bash\ndoc-gen --topic \"Your Topic\" --model gpt-4\n</code></pre> <p>Error Output: <pre><code>[Paste full error output here]\n</code></pre></p> <p>Expected Behavior: [What you expected to happen]</p> <p>Additional Context: [Any other relevant information] ```</p>"},{"location":"examples/troubleshooting/#quick-fixes-reference","title":"Quick Fixes Reference","text":"Issue Quick Fix Module not found <code>pip install -e .</code> API key missing <code>export OPENAI_API_KEY=\"your-key\"</code> Permission denied <code>chmod 755 output/</code> Plugin not loading <code>doc-gen --list-plugins</code> Slow generation <code>--model gpt-3.5-turbo --runs 1</code> Generic output Use more specific topics Rate limit Wait 60 seconds and retry Empty output Check <code>--verbose</code> for errors <p>Most issues can be resolved by carefully reading error messages and following the solutions above. For persistent problems, don't hesitate to seek help through the support channels!</p> <p>Need more help? Check out the Getting Started Guide for basic usage or the Installation Guide for setup issues.</p>"},{"location":"guides/configuration/","title":"Configuration Guide","text":"<p>This guide covers how to customize doc-generator's behavior through configuration files, environment variables, and runtime parameters.</p>"},{"location":"guides/configuration/#configuration-overview","title":"\ud83c\udf9b\ufe0f Configuration Overview","text":"<p>Doc-generator uses multiple configuration layers:</p> <ol> <li>Prompt Templates (<code>prompts/</code>) - Control AI generation behavior</li> <li>Terminology Files (<code>terminology.yaml</code>) - Define HPC modules and commands  </li> <li>Environment Variables (<code>.env</code>) - API keys and runtime settings</li> <li>Command-line Options - Override defaults per execution</li> </ol>"},{"location":"guides/configuration/#prompt-templates","title":"\ud83d\udcdd Prompt Templates","text":""},{"location":"guides/configuration/#default-template-structure","title":"Default Template Structure","text":"<pre><code># prompts/generator/default.yaml\nsystem_prompt: |\n  You are creating {format} documentation for {topic} at {organization}.\n  Focus on practical examples and clear step-by-step instructions.\n\n  Structure your response with these sections:\n  1. Description - Brief overview and purpose\n  2. Installation - Setup instructions with module commands\n  3. Usage - Basic usage examples and syntax\n  4. Examples - Practical code examples and workflows\n  5. References - Relevant links and documentation\n\nplaceholders:\n  format: \"HTML\"\n  organization: \"FASRC\"\n\nuser_prompt: |\n  Create comprehensive documentation for: {topic}\n\n  Include relevant HPC modules, cluster commands, and best practices.\n  Use clear code examples and provide troubleshooting tips.\n</code></pre>"},{"location":"guides/configuration/#custom-templates","title":"Custom Templates","text":"<p>Create specialized templates for different use cases:</p> <pre><code># prompts/generator/api-docs.yaml\nsystem_prompt: |\n  You are creating API documentation for {topic}.\n  Focus on endpoints, parameters, and response examples.\n\n  Required sections:\n  1. Overview - API purpose and authentication\n  2. Endpoints - Available endpoints with HTTP methods\n  3. Parameters - Request/response parameters\n  4. Examples - Code examples in multiple languages\n  5. Error Handling - Common errors and solutions\n\nplaceholders:\n  format: \"HTML\"\n  api_version: \"v1\"\n  base_url: \"https://api.example.com\"\n\nuser_prompt: |\n  Document the {topic} API with complete endpoint reference.\n  Include curl examples and response schemas.\n</code></pre>"},{"location":"guides/configuration/#template-parameters","title":"Template Parameters","text":"<p>Templates support dynamic placeholders:</p> Parameter Description Default <code>{topic}</code> Documentation topic Required <code>{format}</code> Output format <code>\"HTML\"</code> <code>{organization}</code> Organization name <code>\"FASRC\"</code> <code>{date}</code> Current date Auto-generated <code>{model}</code> AI model used Runtime value"},{"location":"guides/configuration/#terminology-configuration","title":"\ud83c\udfd7\ufe0f Terminology Configuration","text":""},{"location":"guides/configuration/#hpc-modules","title":"HPC Modules","text":"<p>Define available software modules:</p> <pre><code># terminology.yaml\nhpc_modules:\n  - name: \"python/3.12.8-fasrc01\"\n    description: \"Python 3.12 with Anaconda distribution\"\n    category: \"programming\"\n    keywords: [\"python\", \"anaconda\", \"data science\"]\n\n  - name: \"gcc/12.2.0-fasrc01\"  \n    description: \"GNU Compiler Collection 12.2\"\n    category: \"compiler\"\n    keywords: [\"gcc\", \"compiler\", \"c\", \"cpp\", \"fortran\"]\n\n  - name: \"cuda/12.9.1-fasrc01\"\n    description: \"NVIDIA CUDA Toolkit 12.9\"\n    category: \"gpu\"\n    keywords: [\"cuda\", \"gpu\", \"nvidia\", \"machine learning\"]\n</code></pre>"},{"location":"guides/configuration/#cluster-commands","title":"Cluster Commands","text":"<p>Define common cluster operations:</p> <pre><code>cluster_commands:\n  - name: \"sbatch\"\n    description: \"Submit a batch job to SLURM\"\n    usage: \"sbatch script.sh\"\n    category: \"job_management\"\n\n  - name: \"squeue\"\n    description: \"View job queue status\"\n    usage: \"squeue -u $USER\"\n    category: \"monitoring\"\n\n  - name: \"module load\"\n    description: \"Load software module\"\n    usage: \"module load python/3.12.8-fasrc01\"\n    category: \"environment\"\n</code></pre>"},{"location":"guides/configuration/#code-examples","title":"Code Examples","text":"<p>Pre-define reusable code snippets:</p> <pre><code>code_examples:\n  python_import:\n    language: \"python\"\n    code: |\n      import numpy as np\n      import pandas as pd\n      import matplotlib.pyplot as plt\n    description: \"Standard Python data science imports\"\n\n  slurm_header:\n    language: \"bash\"\n    code: |\n      #!/bin/bash\n      #SBATCH -J my_job\n      #SBATCH -p shared\n      #SBATCH -t 1:00:00\n      #SBATCH --mem=4G\n    description: \"Basic SLURM job script header\"\n</code></pre>"},{"location":"guides/configuration/#environment-configuration","title":"\ud83d\udd27 Environment Configuration","text":""},{"location":"guides/configuration/#api-keys","title":"API Keys","text":"<pre><code># .env file\nOPENAI_API_KEY=your-openai-api-key-here\nOPENAI_ORGANIZATION=your-org-id  # Optional\n</code></pre>"},{"location":"guides/configuration/#runtime-settings","title":"Runtime Settings","text":"<pre><code># Default model settings\nDOC_GEN_DEFAULT_MODEL=gpt-4o-mini\nDOC_GEN_DEFAULT_TEMPERATURE=0.3\nDOC_GEN_DEFAULT_RUNS=1\n\n# Output settings\nDOC_GEN_OUTPUT_DIR=output\nDOC_GEN_MAX_TOKENS=4000\n\n# Plugin settings\nDOC_GEN_DISABLE_PLUGINS=  # Comma-separated list\nDOC_GEN_PLUGIN_PRIORITY=modules:100,datasets:90\n\n# Debug settings\nDOC_GEN_VERBOSE=false\nDOC_GEN_LOG_LEVEL=INFO\n</code></pre>"},{"location":"guides/configuration/#command-line-configuration","title":"\ud83c\udfaf Command-Line Configuration","text":""},{"location":"guides/configuration/#global-options","title":"Global Options","text":"<pre><code># Model and generation settings\ndoc-gen --model gpt-4 --temperature 0.5 --runs 3\n\n# Output configuration  \ndoc-gen --output-dir custom-docs --format html\n\n# Plugin management\ndoc-gen --disable-plugins modules --enable-only datasets workflows\n\n# Quality and analysis\ndoc-gen --analyze --quality-eval --verbose\n</code></pre>"},{"location":"guides/configuration/#configuration-files-override","title":"Configuration Files Override","text":"<pre><code># Use custom prompt template\ndoc-gen --prompt-yaml prompts/generator/custom.yaml\n\n# Use custom terminology\ndoc-gen --terminology-path config/custom-terminology.yaml\n\n# Use custom examples directory\ndoc-gen --examples-dir examples/specialized/\n</code></pre>"},{"location":"guides/configuration/#plugin-configuration","title":"\ud83d\udd0c Plugin Configuration","text":""},{"location":"guides/configuration/#plugin-specific-settings","title":"Plugin-Specific Settings","text":"<pre><code># terminology.yaml - Plugin configuration section\nplugin_config:\n  modules:\n    priority: 100\n    enabled: true\n    max_recommendations: 5\n    categories: [\"programming\", \"compiler\", \"library\"]\n\n  datasets:\n    priority: 90\n    enabled: false\n    api_timeout: 10\n    cache_duration: 3600\n    sources: [\"zenodo\", \"datahub\"]\n</code></pre>"},{"location":"guides/configuration/#environment-based-plugin-config","title":"Environment-Based Plugin Config","text":"<pre><code># ModuleRecommender settings\nMODULE_RECOMMENDER_MAX_RESULTS=5\nMODULE_RECOMMENDER_MIN_SCORE=3.0\nMODULE_RECOMMENDER_CATEGORIES=programming,compiler\n\n# DatasetRecommender settings  \nDATASET_RECOMMENDER_TIMEOUT=10\nDATASET_RECOMMENDER_CACHE_TTL=3600\nDATASET_RECOMMENDER_SOURCES=zenodo,datahub,nasa\n</code></pre>"},{"location":"guides/configuration/#directory-structure","title":"\ud83d\udcc1 Directory Structure","text":""},{"location":"guides/configuration/#standard-configuration-layout","title":"Standard Configuration Layout","text":"<pre><code>doc-fun/\n\u251c\u2500\u2500 .env                      # Environment variables and API keys\n\u251c\u2500\u2500 terminology.yaml          # HPC modules and cluster commands\n\u251c\u2500\u2500 prompts/\n\u2502   \u251c\u2500\u2500 generator/\n\u2502   \u2502   \u251c\u2500\u2500 default.yaml     # Standard documentation template\n\u2502   \u2502   \u251c\u2500\u2500 markdown.yaml    # Markdown output template\n\u2502   \u2502   \u251c\u2500\u2500 api-docs.yaml    # API documentation template\n\u2502   \u2502   \u2514\u2500\u2500 tutorial.yaml    # Tutorial-focused template\n\u2502   \u2514\u2500\u2500 analysis/\n\u2502       \u251c\u2500\u2500 default.yaml     # Quality evaluation prompts\n\u2502       \u2514\u2500\u2500 technical.yaml   # Technical accuracy evaluation\n\u251c\u2500\u2500 examples/                 # Few-shot learning examples\n\u2502   \u251c\u2500\u2500 matlab.html\n\u2502   \u251c\u2500\u2500 mpi.html\n\u2502   \u2514\u2500\u2500 python.html\n\u2514\u2500\u2500 config/                   # Optional: additional config files\n    \u251c\u2500\u2500 development.yaml\n    \u251c\u2500\u2500 production.yaml\n    \u2514\u2500\u2500 custom-terminology.yaml\n</code></pre>"},{"location":"guides/configuration/#custom-configuration-paths","title":"Custom Configuration Paths","text":"<pre><code># Override default paths\nexport DOC_GEN_CONFIG_DIR=/path/to/custom/config\nexport DOC_GEN_PROMPTS_DIR=/path/to/custom/prompts\nexport DOC_GEN_TERMINOLOGY_PATH=/path/to/custom/terminology.yaml\n</code></pre>"},{"location":"guides/configuration/#output-customization","title":"\ud83c\udfa8 Output Customization","text":""},{"location":"guides/configuration/#html-styling","title":"HTML Styling","text":"<p>Create custom CSS for generated HTML:</p> <pre><code>/* styles/custom.css */\n.doc-generator-output {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto;\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 2rem;\n}\n\n.code-block {\n    background: #f8f9fa;\n    border-left: 4px solid #007bff;\n    padding: 1rem;\n    margin: 1rem 0;\n}\n\n.module-recommendation {\n    background: #e7f3ff;\n    border: 1px solid #b8daff;\n    border-radius: 4px;\n    padding: 0.75rem;\n    margin: 0.5rem 0;\n}\n</code></pre>"},{"location":"guides/configuration/#template-customization","title":"Template Customization","text":"<pre><code># prompts/generator/styled.yaml\nsystem_prompt: |\n  Create HTML documentation with custom styling.\n  Include this CSS in the &lt;head&gt; section:\n  &lt;link rel=\"stylesheet\" href=\"styles/custom.css\"&gt;\n\n  Use these CSS classes:\n  - .doc-generator-output for main container\n  - .code-block for code examples\n  - .module-recommendation for HPC module suggestions\n\nplaceholders:\n  css_framework: \"custom\"\n  include_toc: true\n</code></pre>"},{"location":"guides/configuration/#configuration-profiles","title":"\ud83d\udd04 Configuration Profiles","text":""},{"location":"guides/configuration/#profile-based-configuration","title":"Profile-Based Configuration","text":"<p>Create different configuration profiles:</p> <pre><code># config/profiles.yaml\nprofiles:\n  development:\n    model: \"gpt-3.5-turbo\"\n    temperature: 0.7\n    runs: 1\n    verbose: true\n\n  production:\n    model: \"gpt-4\"\n    temperature: 0.3\n    runs: 3\n    analyze: true\n    quality_eval: true\n\n  research:\n    model: \"gpt-4\"\n    temperature: 0.2\n    runs: 5\n    plugins: [\"modules\", \"datasets\", \"papers\"]\n    output_format: \"academic\"\n</code></pre> <p>Usage:</p> <pre><code># Use specific profile\ndoc-gen --profile production --topic \"Critical Documentation\"\n\n# Override profile settings\ndoc-gen --profile development --model gpt-4 --topic \"Test Topic\"\n</code></pre>"},{"location":"guides/configuration/#advanced-configuration","title":"\ud83e\uddea Advanced Configuration","text":""},{"location":"guides/configuration/#conditional-configuration","title":"Conditional Configuration","text":"<pre><code># prompts/generator/conditional.yaml\nsystem_prompt: |\n  {% if topic contains \"python\" %}\n  Focus on Python-specific examples and best practices.\n  Include pip installation commands and virtual environments.\n  {% elif topic contains \"gpu\" %}\n  Emphasize GPU computing concepts and CUDA examples.\n  Include module load commands for CUDA toolkit.\n  {% else %}\n  Provide general HPC guidance and cluster usage examples.\n  {% endif %}\n\n  Create documentation for: {topic}\n\nplaceholders:\n  topic_type: \"auto-detected\"\n</code></pre>"},{"location":"guides/configuration/#multi-organization-support","title":"Multi-Organization Support","text":"<pre><code># config/organizations.yaml\norganizations:\n  fasrc:\n    name: \"Faculty Arts and Sciences Research Computing\"\n    modules_prefix: \"fasrc01\"\n    scheduler: \"slurm\"\n    documentation_url: \"https://docs.rc.fas.harvard.edu\"\n\n  mit:\n    name: \"MIT SuperCloud\"\n    modules_prefix: \"mit\"\n    scheduler: \"slurm\"  \n    documentation_url: \"https://supercloud.mit.edu\"\n\n  nsf:\n    name: \"XSEDE/ACCESS\"\n    modules_prefix: \"xsede\"\n    scheduler: \"pbs\"\n    documentation_url: \"https://access-ci.org\"\n</code></pre>"},{"location":"guides/configuration/#configuration-validation","title":"\ud83d\udcca Configuration Validation","text":""},{"location":"guides/configuration/#validate-configuration","title":"Validate Configuration","text":"<pre><code># Check configuration syntax\ndoc-gen --validate-config\n\n# Test with dry run\ndoc-gen --topic \"Test\" --dry-run --verbose\n\n# Validate specific files\ndoc-gen --validate-prompts prompts/generator/\ndoc-gen --validate-terminology terminology.yaml\n</code></pre>"},{"location":"guides/configuration/#configuration-schema","title":"Configuration Schema","text":"<pre><code># config/schema.py\nfrom typing import Dict, List, Optional\nfrom pydantic import BaseModel\n\nclass PromptConfig(BaseModel):\n    system_prompt: str\n    user_prompt: str\n    placeholders: Dict[str, str] = {}\n\nclass ModuleConfig(BaseModel):\n    name: str\n    description: str\n    category: str\n    keywords: List[str] = []\n\nclass TerminologyConfig(BaseModel):\n    hpc_modules: List[ModuleConfig]\n    cluster_commands: List[Dict[str, str]] = []\n    code_examples: Dict[str, Dict] = {}\n</code></pre>"},{"location":"guides/configuration/#configuration-best-practices","title":"\u2705 Configuration Best Practices","text":""},{"location":"guides/configuration/#security","title":"Security","text":"<ul> <li>Never commit API keys to version control</li> <li>Use environment variables for sensitive data</li> <li>Rotate API keys regularly</li> <li>Limit API key permissions when possible</li> </ul>"},{"location":"guides/configuration/#organization","title":"Organization","text":"<ul> <li>Use descriptive file names for templates</li> <li>Group related configurations in directories</li> <li>Document custom placeholders and their usage</li> <li>Version control configuration files (except .env)</li> </ul>"},{"location":"guides/configuration/#performance","title":"Performance","text":"<ul> <li>Cache frequently used configurations in memory</li> <li>Use specific prompts rather than generic ones</li> <li>Optimize token usage with concise templates</li> <li>Monitor API costs with usage tracking</li> </ul>"},{"location":"guides/configuration/#maintenance","title":"Maintenance","text":"<ul> <li>Test configuration changes before deploying</li> <li>Keep templates up to date with model capabilities</li> <li>Document custom configurations for team members</li> <li>Regular backup of configuration files</li> </ul> <p>Ready to customize doc-generator for your needs? Start with the Getting Started Guide to learn basic usage, then return here to tailor the system to your requirements.</p>"},{"location":"guides/contributing/","title":"Contributing Guide","text":"<p>Welcome to the doc-generator project! This guide will help you contribute effectively, whether you're fixing bugs, adding features, or creating new plugins.</p>"},{"location":"guides/contributing/#ways-to-contribute","title":"\ud83e\udd1d Ways to Contribute","text":""},{"location":"guides/contributing/#code-contributions","title":"Code Contributions","text":"<ul> <li>Bug fixes - Fix issues and improve stability</li> <li>New features - Add functionality to core system</li> <li>Plugin development - Create new recommendation engines</li> <li>Test improvements - Expand test coverage and quality</li> <li>Documentation - Improve guides and API docs</li> </ul>"},{"location":"guides/contributing/#non-code-contributions","title":"Non-Code Contributions","text":"<ul> <li>Issue reporting - Report bugs and suggest features</li> <li>Documentation - Fix typos, clarify instructions</li> <li>Community support - Help other users in discussions</li> <li>Examples - Contribute usage examples and tutorials</li> </ul>"},{"location":"guides/contributing/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"guides/contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork the repository on GitHub, then clone your fork\ngit clone https://github.com/YOUR-USERNAME/doc-fun.git\ncd doc-fun\n\n# Add upstream remote\ngit remote add upstream https://github.com/fasrc/doc-fun.git\n</code></pre>"},{"location":"guides/contributing/#2-development-setup","title":"2. Development Setup","text":"<pre><code># Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode with all dependencies\npip install -e \".[dev,test]\"\n\n# Install pre-commit hooks (if available)\npre-commit install\n\n# Verify setup\npython -m pytest -v\ndoc-gen --version\n</code></pre>"},{"location":"guides/contributing/#3-create-feature-branch","title":"3. Create Feature Branch","text":"<pre><code># Update your fork\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\n\n# Create feature branch\ngit checkout -b feature/amazing-new-feature\n# or\ngit checkout -b fix/important-bug-fix\n</code></pre>"},{"location":"guides/contributing/#development-workflow","title":"\ud83d\udd27 Development Workflow","text":""},{"location":"guides/contributing/#code-standards","title":"Code Standards","text":""},{"location":"guides/contributing/#python-style","title":"Python Style","text":"<ul> <li>PEP 8 compliance with Black formatting</li> <li>Type hints for all function signatures</li> <li>Docstrings in Google style for all public functions</li> <li>Maximum line length of 88 characters (Black default)</li> </ul> <pre><code>from typing import List, Dict, Optional\n\ndef generate_documentation(\n    topic: str,\n    model: str = \"gpt-4o-mini\",\n    temperature: float = 0.3,\n    context: Optional[Dict] = None\n) -&gt; List[Dict]:\n    \"\"\"Generate documentation for the given topic.\n\n    Args:\n        topic: The topic to document\n        model: OpenAI model to use\n        temperature: Generation temperature (0.0-1.0)\n        context: Optional context dictionary\n\n    Returns:\n        List of generated documentation variants\n\n    Raises:\n        ValueError: If topic is empty or invalid\n        OpenAIError: If API request fails\n    \"\"\"\n    if not topic.strip():\n        raise ValueError(\"Topic cannot be empty\")\n\n    # Implementation here...\n    return results\n</code></pre>"},{"location":"guides/contributing/#code-organization","title":"Code Organization","text":"<ul> <li>Single responsibility principle for classes and functions</li> <li>Clear separation between core logic and plugin system</li> <li>Dependency injection for testability</li> <li>Error handling with specific exception types</li> </ul>"},{"location":"guides/contributing/#testing-requirements","title":"Testing Requirements","text":""},{"location":"guides/contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>New features must have 90%+ test coverage</li> <li>Bug fixes must include regression tests</li> <li>Public API changes require integration tests</li> <li>Plugin interfaces need comprehensive test suites</li> </ul>"},{"location":"guides/contributing/#test-categories","title":"Test Categories","text":"<pre><code># Unit tests - Fast, isolated tests\npython -m pytest tests/unit/ -v\n\n# Integration tests - Plugin and system integration\npython -m pytest tests/integration/ -v\n\n# All tests with coverage\npython -m pytest --cov=src/doc_generator --cov-report=html\n</code></pre>"},{"location":"guides/contributing/#writing-tests","title":"Writing Tests","text":"<pre><code># Test file: tests/test_new_feature.py\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom doc_generator.new_feature import NewFeatureClass\n\nclass TestNewFeature:\n    \"\"\"Test suite for NewFeature functionality.\"\"\"\n\n    def test_basic_functionality(self):\n        \"\"\"Test basic NewFeature operation.\"\"\"\n        feature = NewFeatureClass()\n        result = feature.process_input(\"test input\")\n\n        assert result is not None\n        assert isinstance(result, dict)\n        assert \"status\" in result\n\n    @patch('doc_generator.new_feature.external_api_call')\n    def test_external_dependency(self, mock_api):\n        \"\"\"Test NewFeature with mocked external dependencies.\"\"\"\n        mock_api.return_value = {\"data\": \"test\"}\n\n        feature = NewFeatureClass()\n        result = feature.process_with_api(\"input\")\n\n        mock_api.assert_called_once_with(\"input\")\n        assert result[\"data\"] == \"test\"\n\n    def test_error_handling(self):\n        \"\"\"Test NewFeature error handling.\"\"\"\n        feature = NewFeatureClass()\n\n        with pytest.raises(ValueError, match=\"Invalid input\"):\n            feature.process_input(\"\")\n</code></pre>"},{"location":"guides/contributing/#code-review-process","title":"Code Review Process","text":""},{"location":"guides/contributing/#pre-submission-checklist","title":"Pre-submission Checklist","text":"<ul> <li> All tests pass locally</li> <li> Code follows style guidelines</li> <li> New features have documentation</li> <li> Changes are covered by tests</li> <li> No security vulnerabilities introduced</li> <li> Performance impact considered</li> </ul>"},{"location":"guides/contributing/#formatting-and-linting","title":"Formatting and Linting","text":"<pre><code># Format code with Black\npython -m black src/ tests/\n\n# Check formatting\npython -m black --check src/ tests/\n\n# Lint with flake8\npython -m flake8 src/ tests/\n\n# Type checking with mypy (if configured)\npython -m mypy src/doc_generator/\n</code></pre>"},{"location":"guides/contributing/#plugin-development","title":"\ud83d\udd0c Plugin Development","text":""},{"location":"guides/contributing/#creating-new-plugins","title":"Creating New Plugins","text":""},{"location":"guides/contributing/#1-plugin-interface","title":"1. Plugin Interface","text":"<pre><code># src/doc_generator/plugins/my_plugin.py\nfrom typing import List, Dict, Optional\nfrom doc_generator.plugins.base import RecommendationEngine\n\nclass MyRecommender(RecommendationEngine):\n    \"\"\"Recommends relevant resources for documentation topics.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n        # Plugin-specific initialization\n\n    def get_name(self) -&gt; str:\n        \"\"\"Return unique plugin identifier.\"\"\"\n        return \"my_plugin\"\n\n    def get_supported_types(self) -&gt; List[str]:\n        \"\"\"Return types of recommendations this plugin provides.\"\"\"\n        return [\"resources\", \"tools\", \"references\"]\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Generate recommendations for the given topic.\"\"\"\n        # Implementation here\n        return [\n            {\n                \"title\": \"Relevant Resource\",\n                \"description\": \"Helpful resource for \" + topic,\n                \"url\": \"https://example.com/resource\",\n                \"relevance_score\": 8.5,\n                \"type\": \"resource\"\n            }\n        ]\n\n    def is_enabled(self) -&gt; bool:\n        \"\"\"Check if plugin should be active.\"\"\"\n        return True  # Or check environment/config\n\n    def get_priority(self) -&gt; int:\n        \"\"\"Get plugin execution priority (higher = earlier).\"\"\"\n        return 50  # Default priority\n</code></pre>"},{"location":"guides/contributing/#2-plugin-testing","title":"2. Plugin Testing","text":"<pre><code># tests/test_my_plugin.py\nimport pytest\nfrom doc_generator.plugins.my_plugin import MyRecommender\n\nclass TestMyRecommender:\n    \"\"\"Test suite for MyRecommender plugin.\"\"\"\n\n    def test_plugin_interface(self):\n        \"\"\"Test plugin implements required interface.\"\"\"\n        plugin = MyRecommender()\n\n        assert plugin.get_name() == \"my_plugin\"\n        assert \"resources\" in plugin.get_supported_types()\n        assert plugin.is_enabled() is True\n        assert isinstance(plugin.get_priority(), int)\n\n    def test_get_recommendations(self):\n        \"\"\"Test recommendation generation.\"\"\"\n        plugin = MyRecommender()\n        results = plugin.get_recommendations(\"Python Programming\")\n\n        assert isinstance(results, list)\n        assert len(results) &gt; 0\n\n        for rec in results:\n            assert \"title\" in rec\n            assert \"description\" in rec\n            assert \"relevance_score\" in rec\n            assert isinstance(rec[\"relevance_score\"], (int, float))\n\n    def test_empty_topic_handling(self):\n        \"\"\"Test handling of empty/invalid topics.\"\"\"\n        plugin = MyRecommender()\n        results = plugin.get_recommendations(\"\")\n\n        # Should return empty list, not crash\n        assert isinstance(results, list)\n</code></pre>"},{"location":"guides/contributing/#3-plugin-registration","title":"3. Plugin Registration","text":"<pre><code># For external plugin packages - pyproject.toml\n[project.entry-points.\"doc_generator.plugins\"]\nmy_plugin = \"my_package.plugins:MyRecommender\"\n</code></pre>"},{"location":"guides/contributing/#built-in-plugin-guidelines","title":"Built-in Plugin Guidelines","text":"<ul> <li>Follow existing patterns in <code>src/doc_generator/plugins/modules.py</code></li> <li>Handle errors gracefully - never crash the main generation</li> <li>Log appropriately using <code>self.logger</code></li> <li>Respect rate limits for external APIs</li> <li>Cache results when appropriate</li> <li>Document configuration options clearly</li> </ul>"},{"location":"guides/contributing/#issue-guidelines","title":"\ud83d\udccb Issue Guidelines","text":""},{"location":"guides/contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Use the bug report template:</p> <p><pre><code>**Bug Description**\nA clear description of the bug.\n\n**Steps to Reproduce**\n1. Run command: `doc-gen --topic \"Test\" --model gpt-4`\n2. Observe error in output\n3. Check logs for details\n\n**Expected Behavior**\nDocumentation should generate successfully.\n\n**Actual Behavior**\nProcess crashes with KeyError.\n\n**Environment**\n- OS: macOS 13.2\n- Python: 3.10.8\n- doc-generator: 1.1.0\n- OpenAI: 1.35.3\n\n**Additional Context**\nError occurs only with gpt-4 model, works fine with gpt-3.5-turbo.\n\n**Logs**\n</code></pre> Traceback (most recent call last):   File \"src/doc_generator/core.py\", line 123, in generate KeyError: 'response_format' <pre><code>### Feature Requests\n\nUse the feature request template:\n\n```markdown\n**Feature Description**\nAdd support for generating LaTeX documentation format.\n\n**Use Case**\nAcademic users need LaTeX output for integration with research papers and thesis documents.\n\n**Proposed Solution**\n1. Create LaTeX prompt template in `prompts/generator/latex.yaml`\n2. Add LaTeX formatting options to CLI\n3. Include LaTeX-specific section structure\n\n**Alternative Solutions**\n- Markdown output with Pandoc conversion\n- HTML with LaTeX CSS styling\n\n**Additional Context**\nThis would complement existing HTML and Markdown formats.\n</code></pre></p>"},{"location":"guides/contributing/#pull-request-process","title":"\ud83c\udfaf Pull Request Process","text":""},{"location":"guides/contributing/#1-prepare-your-changes","title":"1. Prepare Your Changes","text":"<pre><code># Ensure tests pass\npython -m pytest -v\n\n# Format code\npython -m black src/ tests/\n\n# Check for issues\npython -m flake8 src/ tests/\n\n# Update documentation if needed\n# Edit relevant files in docs/\n</code></pre>"},{"location":"guides/contributing/#2-commit-guidelines","title":"2. Commit Guidelines","text":"<p>Use conventional commit format:</p> <pre><code># Feature commits\ngit commit -m \"feat: add LaTeX output format support\"\ngit commit -m \"feat(plugins): add DatasetRecommender plugin\"\n\n# Bug fix commits  \ngit commit -m \"fix: handle empty topic input gracefully\"\ngit commit -m \"fix(cli): correct argument parsing for --disable-plugins\"\n\n# Documentation commits\ngit commit -m \"docs: add LaTeX format usage examples\"\ngit commit -m \"docs(api): update plugin interface documentation\"\n\n# Test commits\ngit commit -m \"test: add integration tests for new plugin system\"\n</code></pre>"},{"location":"guides/contributing/#3-pull-request-template","title":"3. Pull Request Template","text":"<pre><code>## Description\nBrief description of changes and motivation.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change that fixes an issue)\n- [ ] New feature (non-breaking change that adds functionality)\n- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n- [ ] Documentation update\n\n## Testing\n- [ ] Unit tests pass\n- [ ] Integration tests pass\n- [ ] New tests added for changes\n- [ ] Manual testing performed\n\n## Checklist\n- [ ] Code follows project style guidelines\n- [ ] Self-review of code completed\n- [ ] Code is commented where needed\n- [ ] Documentation updated where needed\n- [ ] Changes generate no new warnings\n\n## Screenshots (if applicable)\nAdd screenshots to help explain your changes.\n\n## Additional Notes\nAny additional information about the changes.\n</code></pre>"},{"location":"guides/contributing/#4-review-process","title":"4. Review Process","text":""},{"location":"guides/contributing/#reviewer-guidelines","title":"Reviewer Guidelines","text":"<ul> <li>Check functionality - Does the code work as intended?</li> <li>Review tests - Are changes adequately tested?</li> <li>Style compliance - Does code follow project standards?</li> <li>Documentation - Are changes documented appropriately?</li> <li>Performance - Are there any performance implications?</li> <li>Security - Are there any security concerns?</li> </ul>"},{"location":"guides/contributing/#addressing-feedback","title":"Addressing Feedback","text":"<pre><code># Make requested changes\ngit add .\ngit commit -m \"fix: address review feedback for error handling\"\n\n# Update pull request (no need to create new PR)\ngit push origin feature/amazing-new-feature\n</code></pre>"},{"location":"guides/contributing/#recognition","title":"\ud83c\udfc6 Recognition","text":""},{"location":"guides/contributing/#contributors","title":"Contributors","text":"<ul> <li>All contributors are recognized in the project README</li> <li>Significant contributions may be highlighted in release notes</li> <li>Plugin authors are credited in plugin documentation</li> </ul>"},{"location":"guides/contributing/#community","title":"Community","text":"<ul> <li>Help other contributors in GitHub discussions</li> <li>Share your plugins and extensions with the community</li> <li>Contribute to documentation and examples</li> </ul>"},{"location":"guides/contributing/#resources","title":"\ud83d\udcda Resources","text":""},{"location":"guides/contributing/#development-resources","title":"Development Resources","text":"<ul> <li>Python Style Guide - Official Python style guidelines</li> <li>pytest Documentation - Testing framework docs</li> <li>Black Formatter - Code formatting tool</li> <li>Type Hints - Python typing system</li> </ul>"},{"location":"guides/contributing/#project-resources","title":"Project Resources","text":"<ul> <li>Plugin Development Guide - Comprehensive plugin creation guide</li> <li>Testing Guide - Understanding the test suite</li> <li>API Documentation - Auto-generated API docs</li> <li>Architecture Overview - System design patterns</li> </ul>"},{"location":"guides/contributing/#getting-help","title":"\u2753 Getting Help","text":""},{"location":"guides/contributing/#questions-and-support","title":"Questions and Support","text":"<ul> <li>GitHub Discussions - Ask questions and share ideas</li> <li>GitHub Issues - Report bugs and request features</li> <li>FASRC Support - Contact the original development team</li> </ul>"},{"location":"guides/contributing/#best-practices","title":"Best Practices","text":"<ul> <li>Search existing issues before creating new ones</li> <li>Use descriptive titles for issues and PRs</li> <li>Provide minimal reproducible examples for bugs</li> <li>Be respectful and constructive in all interactions</li> </ul> <p>Ready to contribute? Start by exploring the codebase, running the tests, and looking for issues labeled <code>good first issue</code> or <code>help wanted</code>.</p> <p>Thank you for contributing to doc-generator! \ud83c\udf89</p>"},{"location":"guides/creating-plugins/","title":"Creating Plugins Guide","text":"<p>This comprehensive guide shows you how to create powerful plugins for doc-generator, from simple recommendation engines to complex third-party packages.</p>"},{"location":"guides/creating-plugins/#plugin-architecture-overview","title":"\ud83d\udd0c Plugin Architecture Overview","text":""},{"location":"guides/creating-plugins/#what-are-plugins","title":"What are Plugins?","text":"<p>Plugins in doc-generator are recommendation engines that analyze a documentation topic and provide relevant suggestions. They automatically integrate into the documentation generation process to enhance the final output.</p> <p>Built-in Plugin Example: - ModuleRecommender: Suggests relevant HPC modules based on topic keywords - Input: \"Python Machine Learning\" - Output: <code>module load python/3.12.8-fasrc01</code>, <code>module load cuda/12.9.1-fasrc01</code></p>"},{"location":"guides/creating-plugins/#plugin-capabilities","title":"Plugin Capabilities","text":"<p>Plugins can recommend: - Software modules and libraries - Datasets and data sources - Code examples and templates - Workflows and job scripts - Documentation links and references - Best practices and troubleshooting tips</p>"},{"location":"guides/creating-plugins/#plugin-architecture","title":"\ud83c\udfd7\ufe0f Plugin Architecture","text":""},{"location":"guides/creating-plugins/#base-class-recommendationengine","title":"Base Class: RecommendationEngine","text":"<p>All plugins inherit from the <code>RecommendationEngine</code> abstract base class:</p> <pre><code>from doc_generator.plugins import RecommendationEngine\nfrom typing import List, Dict, Optional\n\nclass MyPlugin(RecommendationEngine):\n    def get_name(self) -&gt; str:\n        \"\"\"Return unique plugin identifier\"\"\"\n        return \"my_plugin\"\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Return list of recommendations for the topic\"\"\"\n        return [\n            {\n                \"title\": \"My Recommendation\",\n                \"description\": \"Helpful suggestion\",\n                \"relevance_score\": 8.5\n            }\n        ]\n</code></pre>"},{"location":"guides/creating-plugins/#required-methods","title":"Required Methods","text":"Method Purpose Return Type <code>get_name()</code> Unique plugin identifier <code>str</code> <code>get_recommendations()</code> Main recommendation logic <code>List[Dict]</code>"},{"location":"guides/creating-plugins/#optional-methods","title":"Optional Methods","text":"Method Purpose Default <code>get_supported_types()</code> Types of recommendations <code>[get_name()]</code> <code>get_formatted_recommendations()</code> Custom formatting Auto-formatted <code>is_enabled()</code> Enable/disable plugin <code>True</code> <code>get_priority()</code> Plugin ordering priority <code>50</code>"},{"location":"guides/creating-plugins/#creating-your-first-plugin","title":"\ud83d\ude80 Creating Your First Plugin","text":""},{"location":"guides/creating-plugins/#step-1-simple-dataset-recommender","title":"Step 1: Simple Dataset Recommender","text":"<p>Let's create a plugin that recommends research datasets:</p> <pre><code># my_plugin/dataset_recommender.py\nfrom doc_generator.plugins import RecommendationEngine\nfrom typing import List, Dict, Optional\nimport requests\n\nclass DatasetRecommender(RecommendationEngine):\n    \"\"\"Recommends research datasets based on topic keywords.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n\n        # Dataset sources to search\n        self.dataset_sources = [\n            {\n                \"name\": \"Zenodo\",\n                \"api_url\": \"https://zenodo.org/api/records\",\n                \"search_param\": \"q\"\n            },\n            {\n                \"name\": \"DataHub\", \n                \"api_url\": \"https://datahub.io/api/search\",\n                \"search_param\": \"query\"\n            }\n        ]\n\n    def get_name(self) -&gt; str:\n        return \"datasets\"\n\n    def get_supported_types(self) -&gt; List[str]:\n        return [\"datasets\", \"research_data\", \"data_repositories\"]\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Find relevant datasets for the topic.\"\"\"\n        keywords = self._extract_keywords(topic)\n        datasets = []\n\n        for source in self.dataset_sources:\n            try:\n                source_datasets = self._search_source(source, keywords)\n                datasets.extend(source_datasets)\n            except Exception as e:\n                self.logger.warning(f\"Error searching {source['name']}: {e}\")\n\n        # Sort by relevance and return top 5\n        datasets.sort(key=lambda x: x['relevance_score'], reverse=True)\n        return datasets[:5]\n\n    def _extract_keywords(self, topic: str) -&gt; List[str]:\n        \"\"\"Extract searchable keywords from topic.\"\"\"\n        import re\n        words = re.findall(r'\\w+', topic.lower())\n        # Filter common words\n        stop_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'}\n        return [word for word in words if word not in stop_words and len(word) &gt; 2]\n\n    def _search_source(self, source: Dict, keywords: List[str]) -&gt; List[Dict]:\n        \"\"\"Search a specific data source.\"\"\"\n        query = \" \".join(keywords)\n\n        response = requests.get(\n            source[\"api_url\"],\n            params={source[\"search_param\"]: query, \"size\": 10},\n            timeout=10\n        )\n        response.raise_for_status()\n\n        results = response.json()\n        datasets = []\n\n        # Parse response (format varies by source)\n        if source[\"name\"] == \"Zenodo\":\n            for hit in results.get(\"hits\", {}).get(\"hits\", []):\n                metadata = hit.get(\"metadata\", {})\n                dataset = {\n                    \"title\": metadata.get(\"title\", \"Unknown Dataset\"),\n                    \"description\": metadata.get(\"description\", \"\")[:200] + \"...\",\n                    \"url\": hit.get(\"links\", {}).get(\"html\", \"\"),\n                    \"source\": source[\"name\"],\n                    \"relevance_score\": self._calculate_relevance(metadata.get(\"title\", \"\"), keywords)\n                }\n                datasets.append(dataset)\n\n        return datasets\n\n    def _calculate_relevance(self, title: str, keywords: List[str]) -&gt; float:\n        \"\"\"Calculate relevance score based on keyword matches.\"\"\"\n        title_lower = title.lower()\n        score = 0.0\n\n        for keyword in keywords:\n            if keyword in title_lower:\n                score += 2.0  # Title match worth more\n\n        # Bonus for multiple keyword matches\n        if score &gt;= 4.0:\n            score *= 1.2\n\n        return min(score, 10.0)  # Cap at 10\n\n    def get_formatted_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; str:\n        \"\"\"Format recommendations for documentation context.\"\"\"\n        datasets = self.get_recommendations(topic, context)\n\n        if not datasets:\n            return \"\"\n\n        formatted = \"\\n## Relevant Research Datasets:\\n\\n\"\n        for dataset in datasets:\n            formatted += f\"**{dataset['title']}**\\n\"\n            formatted += f\"- Source: {dataset['source']}\\n\"\n            formatted += f\"- URL: {dataset['url']}\\n\"\n            formatted += f\"- Description: {dataset['description']}\\n\"\n            formatted += f\"- Relevance Score: {dataset['relevance_score']:.1f}/10\\n\\n\"\n\n        return formatted\n</code></pre>"},{"location":"guides/creating-plugins/#step-2-package-structure","title":"Step 2: Package Structure","text":"<p>Create a proper Python package for your plugin:</p> <pre><code>my-dataset-plugin/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_dataset_plugin/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 dataset_recommender.py\n\u2502       \u2514\u2500\u2500 config/\n\u2502           \u2514\u2500\u2500 default_sources.yaml\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_dataset_recommender.py\n\u2502   \u2514\u2500\u2500 fixtures/\n\u2502       \u2514\u2500\u2500 sample_data.py\n\u2514\u2500\u2500 docs/\n    \u2514\u2500\u2500 usage.md\n</code></pre>"},{"location":"guides/creating-plugins/#step-3-package-configuration","title":"Step 3: Package Configuration","text":"<p>pyproject.toml: <pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-dataset-plugin\"\nversion = \"0.1.0\"\ndescription = \"Dataset recommendation plugin for doc-generator\"\nauthors = [{name = \"Your Name\", email = \"your.email@example.com\"}]\nreadme = \"README.md\"\nlicense = {text = \"MIT\"}\nkeywords = [\"documentation\", \"datasets\", \"research\", \"plugin\"]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Researchers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n]\nrequires-python = \"&gt;=3.8\"\ndependencies = [\n    \"doc-generator&gt;=1.1.0\",\n    \"requests&gt;=2.28.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0.0\",\n    \"pytest-cov&gt;=4.0.0\",\n    \"black&gt;=22.0.0\",\n    \"flake8&gt;=5.0.0\",\n]\n\n# This is the key part - register your plugin!\n[project.entry-points.\"doc_generator.plugins\"]\ndatasets = \"my_dataset_plugin.dataset_recommender:DatasetRecommender\"\n\n[project.urls]\nHomepage = \"https://github.com/yourusername/my-dataset-plugin\"\nRepository = \"https://github.com/yourusername/my-dataset-plugin\"\n</code></pre></p>"},{"location":"guides/creating-plugins/#step-4-installation-and-testing","title":"Step 4: Installation and Testing","text":"<pre><code># Install your plugin in development mode\ncd my-dataset-plugin\npip install -e .\n\n# Test that it's discovered\ndoc-gen --list-plugins\n\n# Expected output should include:\n# Plugin: datasets\n#   Class: DatasetRecommender\n#   Module: my_dataset_plugin.dataset_recommender\n\n# Test with documentation generation\ndoc-gen --topic \"Climate Change Research\" --output-dir test-output\n</code></pre>"},{"location":"guides/creating-plugins/#advanced-plugin-examples","title":"\ud83c\udfaf Advanced Plugin Examples","text":""},{"location":"guides/creating-plugins/#example-1-code-template-recommender","title":"Example 1: Code Template Recommender","text":"<pre><code>class CodeTemplateRecommender(RecommendationEngine):\n    \"\"\"Recommends code templates and examples based on programming languages.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n\n        self.template_mappings = {\n            'python': {\n                'patterns': ['python', 'py', 'pandas', 'numpy', 'scipy'],\n                'templates': [\n                    {\n                        'name': 'Python Data Analysis Template',\n                        'description': 'Template for data analysis with pandas',\n                        'url': 'https://github.com/templates/python-data-analysis',\n                        'type': 'jupyter_notebook'\n                    }\n                ]\n            },\n            'r': {\n                'patterns': ['r', 'rstudio', 'statistics', 'statistical'],\n                'templates': [\n                    {\n                        'name': 'R Statistical Analysis Template',\n                        'description': 'Template for statistical analysis in R',\n                        'url': 'https://github.com/templates/r-stats',\n                        'type': 'r_script'\n                    }\n                ]\n            }\n        }\n\n    def get_name(self) -&gt; str:\n        return \"code_templates\"\n\n    def get_supported_types(self) -&gt; List[str]:\n        return [\"code_templates\", \"examples\", \"boilerplate\"]\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        topic_lower = topic.lower()\n        recommendations = []\n\n        for language, config in self.template_mappings.items():\n            # Check if topic matches language patterns\n            if any(pattern in topic_lower for pattern in config['patterns']):\n                for template in config['templates']:\n                    template_copy = template.copy()\n                    template_copy['language'] = language\n                    template_copy['relevance_score'] = self._calculate_template_relevance(topic, template)\n                    recommendations.append(template_copy)\n\n        return sorted(recommendations, key=lambda x: x['relevance_score'], reverse=True)\n\n    def _calculate_template_relevance(self, topic: str, template: Dict) -&gt; float:\n        # Score based on keyword matches in template description\n        topic_words = set(topic.lower().split())\n        template_words = set(template['description'].lower().split())\n\n        common_words = topic_words.intersection(template_words)\n        return len(common_words) * 2.0\n</code></pre>"},{"location":"guides/creating-plugins/#example-2-workflow-recommender","title":"Example 2: Workflow Recommender","text":"<pre><code>class WorkflowRecommender(RecommendationEngine):\n    \"\"\"Recommends SLURM job scripts and workflow templates.\"\"\"\n\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n\n        self.workflow_templates = {\n            'parallel': [\n                {\n                    'name': 'MPI Job Array Template',\n                    'description': 'Template for MPI-based parallel jobs with job arrays',\n                    'script_type': 'slurm',\n                    'use_case': 'parallel_computing'\n                }\n            ],\n            'gpu': [\n                {\n                    'name': 'GPU Training Job Template',\n                    'description': 'Template for GPU-accelerated machine learning training',\n                    'script_type': 'slurm_gpu',\n                    'use_case': 'machine_learning'\n                }\n            ]\n        }\n\n    def get_name(self) -&gt; str:\n        return \"workflows\"\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        topic_lower = topic.lower()\n        recommendations = []\n\n        # Detect workflow type from topic\n        if any(word in topic_lower for word in ['parallel', 'mpi', 'distributed']):\n            recommendations.extend(self._score_templates(self.workflow_templates['parallel'], topic))\n\n        if any(word in topic_lower for word in ['gpu', 'cuda', 'machine learning', 'deep learning']):\n            recommendations.extend(self._score_templates(self.workflow_templates['gpu'], topic))\n\n        return recommendations\n\n    def _score_templates(self, templates: List[Dict], topic: str) -&gt; List[Dict]:\n        scored_templates = []\n        for template in templates:\n            template_copy = template.copy()\n            template_copy['relevance_score'] = 7.0  # Base score for matching category\n            scored_templates.append(template_copy)\n        return scored_templates\n\n    def get_formatted_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; str:\n        workflows = self.get_recommendations(topic, context)\n\n        if not workflows:\n            return \"\"\n\n        formatted = \"\\n## Recommended Workflow Templates:\\n\\n\"\n        for workflow in workflows:\n            formatted += f\"**{workflow['name']}**\\n\"\n            formatted += f\"- Type: {workflow['script_type']}\\n\"\n            formatted += f\"- Use Case: {workflow['use_case']}\\n\"\n            formatted += f\"- Description: {workflow['description']}\\n\\n\"\n\n        return formatted\n</code></pre>"},{"location":"guides/creating-plugins/#testing-your-plugin","title":"\ud83e\uddea Testing Your Plugin","text":""},{"location":"guides/creating-plugins/#basic-plugin-tests","title":"Basic Plugin Tests","text":"<pre><code># tests/test_dataset_recommender.py\nimport pytest\nfrom unittest.mock import Mock, patch\nfrom my_dataset_plugin.dataset_recommender import DatasetRecommender\n\nclass TestDatasetRecommender:\n    \"\"\"Test suite for DatasetRecommender plugin.\"\"\"\n\n    def test_plugin_initialization(self):\n        \"\"\"Test plugin initializes correctly.\"\"\"\n        recommender = DatasetRecommender()\n\n        assert recommender.get_name() == \"datasets\"\n        assert \"datasets\" in recommender.get_supported_types()\n        assert recommender.is_enabled() == True\n\n    def test_keyword_extraction(self):\n        \"\"\"Test keyword extraction from topics.\"\"\"\n        recommender = DatasetRecommender()\n        keywords = recommender._extract_keywords(\"Climate Change Research Data\")\n\n        assert \"climate\" in keywords\n        assert \"change\" in keywords\n        assert \"research\" in keywords\n        assert \"data\" in keywords\n        assert \"the\" not in keywords  # Stop word filtered\n\n    @patch('requests.get')\n    def test_dataset_search_success(self, mock_get):\n        \"\"\"Test successful dataset search.\"\"\"\n        # Mock API response\n        mock_response = Mock()\n        mock_response.json.return_value = {\n            \"hits\": {\n                \"hits\": [\n                    {\n                        \"metadata\": {\n                            \"title\": \"Climate Dataset 2023\",\n                            \"description\": \"Comprehensive climate data\"\n                        },\n                        \"links\": {\"html\": \"https://zenodo.org/record/123\"}\n                    }\n                ]\n            }\n        }\n        mock_response.raise_for_status.return_value = None\n        mock_get.return_value = mock_response\n\n        recommender = DatasetRecommender()\n        recommendations = recommender.get_recommendations(\"Climate Research\")\n\n        assert len(recommendations) &gt; 0\n        assert recommendations[0][\"title\"] == \"Climate Dataset 2023\"\n        assert recommendations[0][\"source\"] == \"Zenodo\"\n\n    @patch('requests.get')\n    def test_api_error_handling(self, mock_get):\n        \"\"\"Test graceful handling of API errors.\"\"\"\n        mock_get.side_effect = requests.RequestException(\"API Error\")\n\n        recommender = DatasetRecommender()\n        recommendations = recommender.get_recommendations(\"Any Topic\")\n\n        # Should return empty list, not crash\n        assert recommendations == []\n\n    def test_formatted_output(self):\n        \"\"\"Test formatted recommendation output.\"\"\"\n        recommender = DatasetRecommender()\n\n        # Mock recommendations\n        with patch.object(recommender, 'get_recommendations') as mock_get_rec:\n            mock_get_rec.return_value = [\n                {\n                    \"title\": \"Test Dataset\",\n                    \"description\": \"Test description\",\n                    \"url\": \"https://example.com\",\n                    \"source\": \"Test Source\",\n                    \"relevance_score\": 8.5\n                }\n            ]\n\n            formatted = recommender.get_formatted_recommendations(\"Test Topic\")\n\n            assert \"## Relevant Research Datasets:\" in formatted\n            assert \"**Test Dataset**\" in formatted\n            assert \"Source: Test Source\" in formatted\n            assert \"8.5/10\" in formatted\n</code></pre>"},{"location":"guides/creating-plugins/#integration-tests","title":"Integration Tests","text":"<pre><code># tests/test_integration.py\nimport pytest\nfrom doc_generator import DocumentationGenerator\nfrom my_dataset_plugin.dataset_recommender import DatasetRecommender\n\ndef test_plugin_integrates_with_doc_generator(temp_dir):\n    \"\"\"Test that plugin integrates properly with doc-generator.\"\"\"\n\n    # Create minimal config files\n    prompt_file = temp_dir / \"prompt.yaml\"\n    terminology_file = temp_dir / \"terminology.yaml\"\n    examples_dir = temp_dir / \"examples\"\n    examples_dir.mkdir()\n\n    prompt_file.write_text(\"system_prompt: 'Test prompt'\")\n    terminology_file.write_text(\"hpc_modules: []\")\n\n    # Mock plugin discovery to include our plugin\n    from unittest.mock import patch\n    mock_entry_point = Mock()\n    mock_entry_point.name = \"datasets\"\n    mock_entry_point.load.return_value = DatasetRecommender\n\n    with patch('doc_generator.plugin_manager.entry_points') as mock_eps:\n        mock_eps.return_value = [mock_entry_point]\n\n        with patch.dict('os.environ', {'OPENAI_API_KEY': 'test-key'}):\n            generator = DocumentationGenerator(\n                prompt_yaml_path=str(prompt_file),\n                terminology_path=str(terminology_file),\n                examples_dir=str(examples_dir)\n            )\n\n            # Plugin should be loaded\n            assert \"datasets\" in generator.plugin_manager.engines\n\n            # Plugin should contribute to context\n            context = generator._build_terminology_context(\"Research Data Analysis\")\n            # Context should contain plugin contributions (depends on mocking API calls)\n</code></pre>"},{"location":"guides/creating-plugins/#plugin-configuration","title":"\ud83c\udf9b\ufe0f Plugin Configuration","text":""},{"location":"guides/creating-plugins/#configuration-files","title":"Configuration Files","text":"<pre><code># my_dataset_plugin/config.py\nimport yaml\nfrom pathlib import Path\n\nclass PluginConfig:\n    \"\"\"Configuration management for dataset plugin.\"\"\"\n\n    def __init__(self, config_path: str = None):\n        if config_path is None:\n            config_path = Path(__file__).parent / \"config\" / \"default_sources.yaml\"\n\n        self.config_path = Path(config_path)\n        self.config = self._load_config()\n\n    def _load_config(self) -&gt; dict:\n        try:\n            with open(self.config_path, 'r') as f:\n                return yaml.safe_load(f)\n        except FileNotFoundError:\n            return self._get_default_config()\n\n    def _get_default_config(self) -&gt; dict:\n        return {\n            \"dataset_sources\": [\n                {\n                    \"name\": \"Zenodo\",\n                    \"api_url\": \"https://zenodo.org/api/records\",\n                    \"enabled\": True\n                }\n            ],\n            \"search_limits\": {\n                \"max_results_per_source\": 10,\n                \"total_max_results\": 5\n            }\n        }\n\n    def get_sources(self) -&gt; list:\n        return [s for s in self.config[\"dataset_sources\"] if s.get(\"enabled\", True)]\n</code></pre> <p>config/default_sources.yaml: <pre><code>dataset_sources:\n  - name: \"Zenodo\"\n    api_url: \"https://zenodo.org/api/records\"\n    search_param: \"q\"\n    enabled: true\n\n  - name: \"DataHub\"\n    api_url: \"https://datahub.io/api/search\"\n    search_param: \"query\"\n    enabled: true\n\n  - name: \"NASA Data\"\n    api_url: \"https://data.nasa.gov/api/search\"\n    search_param: \"q\"\n    enabled: false  # Disabled by default\n\nsearch_limits:\n  max_results_per_source: 10\n  total_max_results: 5\n  timeout_seconds: 10\n\nrelevance_scoring:\n  title_match_weight: 3.0\n  description_match_weight: 1.0\n  keyword_bonus_threshold: 2\n  keyword_bonus_multiplier: 1.2\n</code></pre></p>"},{"location":"guides/creating-plugins/#environment-variables","title":"Environment Variables","text":"<pre><code># Support environment-based configuration\nimport os\n\nclass DatasetRecommender(RecommendationEngine):\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n\n        # Allow environment variable overrides\n        self.api_timeout = int(os.getenv('DATASET_API_TIMEOUT', '10'))\n        self.max_results = int(os.getenv('DATASET_MAX_RESULTS', '5'))\n        self.enable_caching = os.getenv('DATASET_ENABLE_CACHE', 'true').lower() == 'true'\n</code></pre>"},{"location":"guides/creating-plugins/#publishing-your-plugin","title":"\ud83d\ude80 Publishing Your Plugin","text":""},{"location":"guides/creating-plugins/#step-1-prepare-for-distribution","title":"Step 1: Prepare for Distribution","text":"<pre><code># Ensure your package is ready\ncd my-dataset-plugin\n\n# Run tests\npython -m pytest\n\n# Check package structure\npython -m build --check\n\n# Build distribution packages\npython -m build\n</code></pre>"},{"location":"guides/creating-plugins/#step-2-publish-to-pypi","title":"Step 2: Publish to PyPI","text":"<pre><code># Install twine for uploading\npip install twine\n\n# Upload to Test PyPI first\ntwine upload --repository testpypi dist/*\n\n# Test installation from Test PyPI\npip install --index-url https://test.pypi.org/simple/ my-dataset-plugin\n\n# If everything works, upload to real PyPI\ntwine upload dist/*\n</code></pre>"},{"location":"guides/creating-plugins/#step-3-documentation","title":"Step 3: Documentation","text":"<p>README.md for your plugin: <pre><code># Dataset Recommender Plugin for doc-generator\n\nAutomatically discover and recommend relevant research datasets for your documentation.\n\n## Installation\n\n```bash\npip install my-dataset-plugin\n</code></pre></p>"},{"location":"guides/creating-plugins/#usage","title":"Usage","text":"<p>The plugin automatically integrates with doc-generator:</p> <pre><code>doc-gen --topic \"Climate Research\" --output-dir ./docs\n</code></pre> <p>Generated documentation will include relevant dataset recommendations.</p>"},{"location":"guides/creating-plugins/#configuration","title":"Configuration","text":"<p>Create <code>dataset_config.yaml</code> to customize data sources:</p> <pre><code>dataset_sources:\n  - name: \"My Custom API\"\n    api_url: \"https://my-api.com/search\"\n    enabled: true\n</code></pre>"},{"location":"guides/creating-plugins/#supported-data-sources","title":"Supported Data Sources","text":"<ul> <li>Zenodo</li> <li>DataHub  </li> <li>NASA Open Data</li> <li>Custom APIs (configurable) <pre><code>## \ud83c\udfaf Best Practices\n\n### Plugin Design Principles\n\n1. **Single Responsibility**: Each plugin should focus on one type of recommendation\n2. **Fail Gracefully**: Handle API errors, network issues, and missing data\n3. **Configurable**: Allow users to customize behavior through configuration\n4. **Performant**: Cache results, limit API calls, handle timeouts\n5. **Well-Tested**: Comprehensive test coverage including error conditions\n\n### Error Handling\n\n```python\ndef get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n    \"\"\"Get recommendations with robust error handling.\"\"\"\n    try:\n        # Main recommendation logic\n        return self._get_recommendations_impl(topic, context)\n    except requests.RequestException as e:\n        self.logger.warning(f\"Network error in {self.get_name()}: {e}\")\n        return []\n    except Exception as e:\n        self.logger.error(f\"Unexpected error in {self.get_name()}: {e}\")\n        return []  # Never crash the main generation process\n\ndef _get_recommendations_impl(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n    \"\"\"Internal implementation with specific error handling.\"\"\"\n    # Your actual logic here\n    pass\n</code></pre></li> </ul>"},{"location":"guides/creating-plugins/#performance-optimization","title":"Performance Optimization","text":"<pre><code>import functools\nimport time\n\nclass DatasetRecommender(RecommendationEngine):\n    def __init__(self, terminology: Optional[Dict] = None, **kwargs):\n        super().__init__(terminology, **kwargs)\n        self._cache = {}\n        self._cache_ttl = 3600  # 1 hour\n\n    @functools.lru_cache(maxsize=100)\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        \"\"\"Cached recommendations to avoid repeated API calls.\"\"\"\n        cache_key = f\"{topic}:{hash(str(context))}\"\n\n        # Check cache\n        if cache_key in self._cache:\n            cached_data, timestamp = self._cache[cache_key]\n            if time.time() - timestamp &lt; self._cache_ttl:\n                return cached_data\n\n        # Get fresh data\n        recommendations = self._fetch_recommendations(topic, context)\n\n        # Cache results\n        self._cache[cache_key] = (recommendations, time.time())\n\n        return recommendations\n</code></pre>"},{"location":"guides/creating-plugins/#logging-and-debugging","title":"Logging and Debugging","text":"<pre><code>import logging\n\nclass DatasetRecommender(RecommendationEngine):\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        self.logger.debug(f\"Getting dataset recommendations for topic: {topic}\")\n\n        keywords = self._extract_keywords(topic)\n        self.logger.debug(f\"Extracted keywords: {keywords}\")\n\n        recommendations = []\n        for source in self.dataset_sources:\n            try:\n                results = self._search_source(source, keywords)\n                self.logger.debug(f\"Found {len(results)} results from {source['name']}\")\n                recommendations.extend(results)\n            except Exception as e:\n                self.logger.warning(f\"Error searching {source['name']}: {e}\")\n\n        self.logger.info(f\"Returning {len(recommendations)} total recommendations\")\n        return recommendations\n</code></pre>"},{"location":"guides/creating-plugins/#advanced-plugin-features","title":"\ud83d\udd27 Advanced Plugin Features","text":""},{"location":"guides/creating-plugins/#custom-priority-and-ordering","title":"Custom Priority and Ordering","text":"<pre><code>class HighPriorityPlugin(RecommendationEngine):\n    def get_priority(self) -&gt; int:\n        return 200  # Higher than default (50), will appear first\n\n    def is_enabled(self) -&gt; bool:\n        # Could check environment variables, config files, etc.\n        return os.getenv('ENABLE_HIGH_PRIORITY_PLUGIN', 'true').lower() == 'true'\n</code></pre>"},{"location":"guides/creating-plugins/#context-aware-recommendations","title":"Context-Aware Recommendations","text":"<pre><code>def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n    \"\"\"Provide context-aware recommendations.\"\"\"\n    recommendations = self._get_base_recommendations(topic)\n\n    if context:\n        # Adjust based on user preferences\n        if context.get('user_level') == 'beginner':\n            recommendations = [r for r in recommendations if r.get('difficulty', 'medium') == 'easy']\n\n        # Filter by organization\n        if context.get('organization') == 'FASRC':\n            recommendations = [r for r in recommendations if 'fasrc' in r.get('tags', [])]\n\n        # Limit results based on context\n        max_results = context.get('max_results', 5)\n        recommendations = recommendations[:max_results]\n\n    return recommendations\n</code></pre>"},{"location":"guides/creating-plugins/#plugin-dependencies","title":"Plugin Dependencies","text":"<pre><code># In pyproject.toml\ndependencies = [\n    \"doc-generator&gt;=1.1.0\",\n    \"requests&gt;=2.28.0\",\n    \"beautifulsoup4&gt;=4.11.0\",  # For HTML parsing\n    \"pandas&gt;=1.5.0\",           # For data manipulation\n    \"scikit-learn&gt;=1.1.0\",     # For text similarity\n]\n\n# In plugin code\ntry:\n    from sklearn.feature_extraction.text import TfidfVectorizer\n    from sklearn.metrics.pairwise import cosine_similarity\n    HAS_SKLEARN = True\nexcept ImportError:\n    HAS_SKLEARN = False\n\nclass AdvancedDatasetRecommender(RecommendationEngine):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        if HAS_SKLEARN:\n            self.vectorizer = TfidfVectorizer(stop_words='english')\n            self.use_advanced_matching = True\n        else:\n            self.logger.warning(\"scikit-learn not available, using basic matching\")\n            self.use_advanced_matching = False\n</code></pre>"},{"location":"guides/creating-plugins/#plugin-examples-repository","title":"\ud83d\udcda Plugin Examples Repository","text":""},{"location":"guides/creating-plugins/#community-plugin-ideas","title":"Community Plugin Ideas","text":"<p>Here are ideas for plugins that would benefit the community:</p> <ol> <li>Academic Paper Recommender: Suggest relevant research papers from arXiv, PubMed</li> <li>Software License Checker: Recommend appropriate licenses for software projects</li> <li>Container Image Recommender: Suggest Docker/Singularity images for workflows</li> <li>Best Practices Recommender: Suggest coding standards and best practices</li> <li>Security Scanner: Recommend security best practices and vulnerability checks</li> <li>Performance Optimizer: Suggest performance improvements and profiling tools</li> <li>Collaboration Tools: Recommend git workflows, issue templates, documentation templates</li> </ol>"},{"location":"guides/creating-plugins/#example-academic-paper-recommender","title":"Example: Academic Paper Recommender","text":"<pre><code>class PaperRecommender(RecommendationEngine):\n    \"\"\"Recommends relevant academic papers from arXiv and PubMed.\"\"\"\n\n    def get_name(self) -&gt; str:\n        return \"papers\"\n\n    def get_recommendations(self, topic: str, context: Optional[Dict] = None) -&gt; List[Dict]:\n        papers = []\n\n        # Search arXiv for CS/physics papers\n        if self._is_cs_topic(topic):\n            papers.extend(self._search_arxiv(topic))\n\n        # Search PubMed for bio/medical papers  \n        if self._is_bio_topic(topic):\n            papers.extend(self._search_pubmed(topic))\n\n        return sorted(papers, key=lambda x: x['relevance_score'], reverse=True)[:5]\n\n    def _search_arxiv(self, topic: str) -&gt; List[Dict]:\n        # Implementation for arXiv API\n        pass\n\n    def _search_pubmed(self, topic: str) -&gt; List[Dict]:\n        # Implementation for PubMed API  \n        pass\n</code></pre>"},{"location":"guides/creating-plugins/#next-steps","title":"\u2705 Next Steps","text":"<p>After creating your plugin:</p> <ol> <li>\ud83d\udcdd Document Your Plugin: Write clear README, usage examples, configuration docs</li> <li>\ud83e\uddea Test Thoroughly: Unit tests, integration tests, error condition tests</li> <li>\ud83d\ude80 Publish: Share on PyPI, GitHub, announce to the community</li> <li>\ud83e\udd1d Contribute: Consider contributing your plugin to the main doc-generator repository</li> <li>\ud83d\udd04 Maintain: Keep dependencies updated, fix bugs, add features based on user feedback</li> </ol>"},{"location":"guides/creating-plugins/#plugin-creation-mastery","title":"\ud83c\udf89 Plugin Creation Mastery","text":"<p>You now have the knowledge to: - Create powerful recommendation engine plugins - Handle errors gracefully and perform efficiently - Test plugins thoroughly with proper mocking - Configure plugins for flexibility and customization - Publish and distribute plugins to the community - Follow best practices for maintainable code</p> <p>Start building amazing plugins! \ud83d\udd0c\u2728</p> <p>The doc-generator ecosystem awaits your contributions. Whether it's dataset recommendations, code templates, workflow suggestions, or entirely new types of assistance, your plugins will help researchers and developers create better documentation faster.</p> <p>Happy plugin developing! \ud83c\udfaf\ud83d\ude80</p>"},{"location":"guides/getting-started/","title":"Getting Started Guide","text":"<p>This guide will walk you through your first steps with doc-generator, from basic usage to advanced features.</p>"},{"location":"guides/getting-started/#overview","title":"\ud83c\udfaf Overview","text":"<p>Doc-generator is an AI-powered tool that creates high-quality technical documentation using OpenAI's GPT models. It features an extensible plugin architecture that provides intelligent recommendations for HPC modules, code examples, and more.</p>"},{"location":"guides/getting-started/#your-first-documentation","title":"\ud83d\ude80 Your First Documentation","text":""},{"location":"guides/getting-started/#step-1-basic-generation","title":"Step 1: Basic Generation","text":"<p>Let's create your first piece of documentation:</p> <pre><code># Generate documentation for a simple topic\ndoc-gen --topic \"Python Programming\" --output-dir ./my-docs\n\n# Check the output\nls -la my-docs/\ncat my-docs/python_programming_gpt4omini_temp03.html\n</code></pre> <p>What happened? - Doc-generator analyzed the topic \"Python Programming\" - The ModuleRecommender plugin suggested relevant HPC modules - GPT generated structured documentation with recommended modules - Output saved as HTML file with descriptive filename</p>"},{"location":"guides/getting-started/#step-2-multiple-variants","title":"Step 2: Multiple Variants","text":"<p>Generate multiple versions to compare quality:</p> <pre><code># Generate 3 variants with different temperature settings\ndoc-gen --topic \"Machine Learning with GPU\" --runs 3 --temperature 0.7\n\n# Compare the generated files\nls -la output/machine_learning_with_gpu_*\n</code></pre> <p>Why multiple runs? - Different temperature settings produce varied outputs - You can select the best version manually - Future versions will include automatic best-variant selection</p>"},{"location":"guides/getting-started/#step-3-custom-output-location","title":"Step 3: Custom Output Location","text":"<p>Organize your documentation:</p> <pre><code># Create organized output structure\nmkdir -p docs/{tutorials,references,examples}\n\n# Generate documentation in specific location\ndoc-gen --topic \"SLURM Job Scheduling\" --output-dir docs/tutorials\ndoc-gen --topic \"MPI Programming\" --output-dir docs/references\ndoc-gen --topic \"Python Examples\" --output-dir docs/examples\n</code></pre>"},{"location":"guides/getting-started/#understanding-plugins","title":"\ud83d\udd0c Understanding Plugins","text":""},{"location":"guides/getting-started/#view-available-plugins","title":"View Available Plugins","text":"<pre><code># List all loaded plugins\ndoc-gen --list-plugins\n</code></pre> <p>Expected Output: <pre><code>Available Recommendation Engine Plugins:\n==================================================\n\nPlugin: modules\n  Class: ModuleRecommender\n  Module: doc_generator.plugins.modules\n  Supported Types: hpc_modules, software, compilers, libraries\n  Priority: 100\n  Enabled: True\n</code></pre></p>"},{"location":"guides/getting-started/#plugin-integration","title":"Plugin Integration","text":"<p>See how plugins enhance your documentation:</p> <pre><code># Generate documentation and observe module recommendations\ndoc-gen --topic \"Parallel Python with NumPy\" --runs 1 --verbose\n\n# The output will include:\n# - Recommended HPC modules (python/3.12.8-fasrc01, etc.)\n# - Load commands (module load python/3.12.8-fasrc01)\n# - Relevant descriptions and categories\n</code></pre>"},{"location":"guides/getting-started/#command-line-options","title":"\ud83c\udf9b\ufe0f Command Line Options","text":""},{"location":"guides/getting-started/#essential-options","title":"Essential Options","text":"Option Purpose Example <code>--topic</code> What to document <code>--topic \"CUDA Programming\"</code> <code>--output-dir</code> Where to save <code>--output-dir ./gpu-docs</code> <code>--runs</code> Number of variants <code>--runs 5</code> <code>--model</code> GPT model to use <code>--model gpt-4</code> <code>--temperature</code> Creativity level <code>--temperature 0.3</code>"},{"location":"guides/getting-started/#advanced-options","title":"Advanced Options","text":"<pre><code># Analysis and quality evaluation\ndoc-gen --topic \"Deep Learning\" --analyze --quality-eval\n\n# Plugin management\ndoc-gen --topic \"Statistics\" --disable-plugins modules\ndoc-gen --topic \"Data Science\" --enable-only datasets workflows\n\n# Verbose output for debugging\ndoc-gen --topic \"Debug Test\" --verbose\n</code></pre>"},{"location":"guides/getting-started/#configuration-files","title":"\ud83d\udcdd Configuration Files","text":""},{"location":"guides/getting-started/#understanding-the-structure","title":"Understanding the Structure","text":"<pre><code>doc-fun/\n\u251c\u2500\u2500 prompts/\n\u2502   \u251c\u2500\u2500 generator/\n\u2502   \u2502   \u251c\u2500\u2500 default.yaml      # Main prompt template\n\u2502   \u2502   \u251c\u2500\u2500 markdown.yaml     # Markdown format template\n\u2502   \u2502   \u2514\u2500\u2500 custom.yaml       # Your custom templates\n\u2502   \u2514\u2500\u2500 analysis/\n\u2502       \u2514\u2500\u2500 default.yaml      # Quality evaluation prompts\n\u251c\u2500\u2500 terminology.yaml          # HPC modules and commands\n\u251c\u2500\u2500 examples/                 # Few-shot learning examples\n\u2514\u2500\u2500 .env                     # API keys and secrets\n</code></pre>"},{"location":"guides/getting-started/#customizing-prompts","title":"Customizing Prompts","text":"<p>Create a custom prompt template:</p> <pre><code># Create custom prompt\ncat &gt; prompts/generator/my-custom.yaml &lt;&lt; 'EOF'\nsystem_prompt: |\n  You are a technical writer creating {format} documentation for {topic}.\n  Focus on practical examples and clear step-by-step instructions.\n  Include troubleshooting sections and best practices.\n\nplaceholders:\n  format: \"HTML\"\n  organization: \"My Organization\"\n\nuser_prompt: |\n  Create comprehensive documentation for: {topic}\n\n  Structure:\n  1. Overview and Purpose\n  2. Prerequisites and Setup\n  3. Step-by-Step Instructions\n  4. Common Issues and Solutions\n  5. Best Practices\n  6. Additional Resources\nEOF\n\n# Use custom prompt\ndoc-gen --topic \"Custom Topic\" --prompt-yaml prompts/generator/my-custom.yaml\n</code></pre>"},{"location":"guides/getting-started/#modifying-terminology","title":"Modifying Terminology","text":"<p>Add your own HPC modules:</p> <pre><code># Edit terminology.yaml\ncat &gt;&gt; terminology.yaml &lt;&lt; 'EOF'\nhpc_modules:\n  - name: \"my-custom-tool/1.0.0\"\n    description: \"My organization's custom tool\"\n    category: \"custom\"\n  - name: \"internal-library/2.1.0\"  \n    description: \"Internal computational library\"\n    category: \"library\"\nEOF\n</code></pre>"},{"location":"guides/getting-started/#advanced-features","title":"\ud83d\udd2c Advanced Features","text":""},{"location":"guides/getting-started/#code-scanning","title":"Code Scanning","text":"<p>Automatically discover code examples in your project:</p> <pre><code># Scan current directory for code examples\ndoc-gen --scan-code . --max-scan-files 100\n\n# Generate documentation with discovered examples\ndoc-gen --topic \"Project Overview\" --runs 1\n</code></pre>"},{"location":"guides/getting-started/#quality-analysis","title":"Quality Analysis","text":"<p>Get detailed quality reports:</p> <pre><code># Generate with analysis\ndoc-gen --topic \"Algorithm Implementation\" --runs 3 --analyze --quality-eval\n\n# Check generated analysis files\nls -la output/*analysis*\nls -la output/*evaluation*\n</code></pre>"},{"location":"guides/getting-started/#batch-processing","title":"Batch Processing","text":"<p>Process multiple topics efficiently:</p> <pre><code># Create topics file\ncat &gt; topics.txt &lt;&lt; 'EOF'\nPython Data Analysis\nR Statistical Computing\nMATLAB Numerical Methods\nJulia High Performance\nEOF\n\n# Process all topics\nwhile read topic; do\n    echo \"Processing: $topic\"\n    doc-gen --topic \"$topic\" --output-dir \"batch-output\"\n    sleep 2  # Rate limiting\ndone &lt; topics.txt\n</code></pre>"},{"location":"guides/getting-started/#output-formats","title":"\ud83c\udfa8 Output Formats","text":""},{"location":"guides/getting-started/#html-default","title":"HTML (Default)","text":"<pre><code># Generate HTML documentation\ndoc-gen --topic \"Web Documentation\" --output-dir html-docs\n\n# View in browser\nopen html-docs/*.html\n</code></pre>"},{"location":"guides/getting-started/#markdown","title":"Markdown","text":"<pre><code># Use markdown template\ndoc-gen --topic \"GitHub Documentation\" \\\n  --prompt-yaml prompts/generator/markdown.yaml \\\n  --output-dir markdown-docs\n</code></pre>"},{"location":"guides/getting-started/#custom-formatting","title":"Custom Formatting","text":"<p>Modify prompt templates to control output format:</p> <pre><code># In your prompt template\nsystem_prompt: |\n  Generate documentation in {format} format.\n  Use proper {format} syntax and structure.\n\nplaceholders:\n  format: \"reStructuredText\"  # or \"LaTeX\", \"AsciiDoc\", etc.\n</code></pre>"},{"location":"guides/getting-started/#workflow-examples","title":"\ud83d\udd04 Workflow Examples","text":""},{"location":"guides/getting-started/#academic-research-workflow","title":"Academic Research Workflow","text":"<pre><code># 1. Document research methodology\ndoc-gen --topic \"Computational Biology Pipeline\" --output-dir research/methods\n\n# 2. Create software documentation\ndoc-gen --topic \"Bioinformatics Tools Setup\" --output-dir research/software\n\n# 3. Generate user guides\ndoc-gen --topic \"Running Genomic Analysis\" --output-dir research/guides\n\n# 4. Create troubleshooting docs\ndoc-gen --topic \"Common Pipeline Errors\" --output-dir research/troubleshooting\n</code></pre>"},{"location":"guides/getting-started/#software-development-workflow","title":"Software Development Workflow","text":"<pre><code># 1. API documentation\ndoc-gen --topic \"REST API Reference\" --output-dir docs/api\n\n# 2. Installation guides\ndoc-gen --topic \"Development Environment Setup\" --output-dir docs/setup\n\n# 3. User tutorials\ndoc-gen --topic \"Getting Started Tutorial\" --output-dir docs/tutorials\n\n# 4. Deployment guides\ndoc-gen --topic \"Production Deployment\" --output-dir docs/deployment\n</code></pre>"},{"location":"guides/getting-started/#hpc-user-support-workflow","title":"HPC User Support Workflow","text":"<pre><code># 1. User onboarding\ndoc-gen --topic \"New User Guide\" --output-dir support/onboarding\n\n# 2. Software tutorials\ndoc-gen --topic \"SLURM Job Submission\" --output-dir support/tutorials\n\n# 3. Troubleshooting guides\ndoc-gen --topic \"Common SLURM Issues\" --output-dir support/troubleshooting\n\n# 4. Best practices\ndoc-gen --topic \"Cluster Resource Optimization\" --output-dir support/best-practices\n</code></pre>"},{"location":"guides/getting-started/#debugging-and-troubleshooting","title":"\ud83d\udc1b Debugging and Troubleshooting","text":""},{"location":"guides/getting-started/#common-issues","title":"Common Issues","text":""},{"location":"guides/getting-started/#issue-no-module-recommendations-appearing","title":"Issue: No module recommendations appearing","text":"<pre><code># Check if modules plugin is loaded\ndoc-gen --list-plugins\n\n# Verify terminology file has modules\nhead -20 terminology.yaml\n\n# Test module recommender directly\npython -c \"\nfrom doc_generator.plugins.modules import ModuleRecommender\nimport yaml\nwith open('terminology.yaml') as f:\n    term = yaml.safe_load(f)\nrec = ModuleRecommender(terminology=term)\nprint(rec.get_recommendations('Python'))\n\"\n</code></pre>"},{"location":"guides/getting-started/#issue-poor-quality-output","title":"Issue: Poor quality output","text":"<pre><code># Try different temperature settings\ndoc-gen --topic \"Same Topic\" --temperature 0.1  # More focused\ndoc-gen --topic \"Same Topic\" --temperature 0.7  # More creative\n\n# Use more specific topics\ndoc-gen --topic \"Python pandas DataFrame operations for time series analysis\"\n# instead of\ndoc-gen --topic \"Python\"\n\n# Add context to topics\ndoc-gen --topic \"SLURM job arrays for Monte Carlo simulations on FASRC cluster\"\n</code></pre>"},{"location":"guides/getting-started/#issue-api-rate-limiting","title":"Issue: API rate limiting","text":"<pre><code># Add delays between requests\ndoc-gen --topic \"Topic 1\" &amp;&amp; sleep 5 &amp;&amp; doc-gen --topic \"Topic 2\"\n\n# Use lower-cost models for testing\ndoc-gen --topic \"Test Topic\" --model gpt-3.5-turbo\n\n# Monitor API usage\n# Check your OpenAI dashboard for current usage\n</code></pre>"},{"location":"guides/getting-started/#verbose-mode","title":"Verbose Mode","text":"<p>Get detailed information about what's happening:</p> <pre><code># Enable verbose logging\ndoc-gen --topic \"Debug Topic\" --verbose\n\n# This shows:\n# - Plugin loading process\n# - API requests and responses\n# - File operations\n# - Error details\n</code></pre>"},{"location":"guides/getting-started/#performance-tips","title":"\ud83d\udcc8 Performance Tips","text":""},{"location":"guides/getting-started/#optimize-generation-speed","title":"Optimize Generation Speed","text":"<pre><code># Use faster model for drafts\ndoc-gen --topic \"Draft Content\" --model gpt-3.5-turbo\n\n# Reduce runs for testing\ndoc-gen --topic \"Test Topic\" --runs 1\n\n# Use specific topics to reduce API token usage\ndoc-gen --topic \"Specific numpy array slicing techniques\"\n</code></pre>"},{"location":"guides/getting-started/#optimize-quality","title":"Optimize Quality","text":"<pre><code># Use higher-quality model for final versions\ndoc-gen --topic \"Production Documentation\" --model gpt-4\n\n# Generate multiple variants and compare\ndoc-gen --topic \"Important Guide\" --runs 5 --analyze\n\n# Use lower temperature for technical accuracy\ndoc-gen --topic \"API Reference\" --temperature 0.2\n</code></pre>"},{"location":"guides/getting-started/#best-practices","title":"\ud83c\udf93 Best Practices","text":""},{"location":"guides/getting-started/#topic-formulation","title":"Topic Formulation","text":"<p>Good Topics: - \"SLURM job arrays for parameter sweeps on FASRC\" - \"PyTorch distributed training with multiple GPUs\" - \"R parallel processing with foreach and doParallel\"</p> <p>Poor Topics: - \"Help\" - \"Programming\" - \"Cluster\"</p>"},{"location":"guides/getting-started/#documentation-organization","title":"Documentation Organization","text":"<pre><code># Use consistent directory structure\nmkdir -p docs/{user-guides,admin-guides,tutorials,reference,troubleshooting}\n\n# Use descriptive output directories\ndoc-gen --topic \"User Guide\" --output-dir docs/user-guides\ndoc-gen --topic \"Admin Tasks\" --output-dir docs/admin-guides\n</code></pre>"},{"location":"guides/getting-started/#quality-assurance","title":"Quality Assurance","text":"<pre><code># Always review generated content\ndoc-gen --topic \"Critical Documentation\" --runs 3 --analyze\n\n# Test recommendations manually\n# If doc suggests \"module load python/3.12.8-fasrc01\"\n# Verify: module avail python\n\n# Version control your configs\ngit add prompts/ terminology.yaml\ngit commit -m \"Update documentation templates\"\n</code></pre>"},{"location":"guides/getting-started/#next-steps","title":"\u2705 Next Steps","text":"<p>Now that you understand the basics:</p> <ol> <li>\ud83e\uddea Learn Testing - Run and create tests</li> <li>\ud83d\udd0c Create Plugins - Extend functionality  </li> <li>\ud83d\udcda Advanced Configuration - Customize templates</li> <li>\ud83e\udd1d Contributing - Help improve doc-generator</li> </ol>"},{"location":"guides/getting-started/#youre-ready","title":"\ud83c\udf89 You're Ready!","text":"<p>You now have the knowledge to: - Generate high-quality documentation - Customize prompts and templates - Use plugins effectively - Optimize for your workflow - Debug common issues</p> <p>Happy documenting! \ud83d\udcd6\u2728</p>"},{"location":"guides/installation/","title":"Installation Guide","text":"<p>This guide covers different ways to install and set up doc-generator for development and production use.</p>"},{"location":"guides/installation/#prerequisites","title":"\ud83d\udccb Prerequisites","text":""},{"location":"guides/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: 3.8 or higher</li> <li>Operating System: Linux, macOS, or Windows</li> <li>Memory: 2GB RAM minimum (4GB+ recommended for large documentation sets)</li> <li>Storage: 500MB for installation + space for generated documentation</li> </ul>"},{"location":"guides/installation/#required-dependencies","title":"Required Dependencies","text":"<ul> <li><code>openai&gt;=1.0.0</code> - OpenAI API client</li> <li><code>pyyaml&gt;=6.0</code> - YAML configuration parsing</li> <li><code>python-dotenv&gt;=0.19.0</code> - Environment variable management</li> <li><code>beautifulsoup4&gt;=4.11.0</code> - HTML parsing and analysis</li> <li><code>pandas&gt;=1.5.0</code> - Data analysis and reporting</li> <li><code>tabulate&gt;=0.9.0</code> - Table formatting</li> </ul>"},{"location":"guides/installation/#quick-installation","title":"\ud83d\ude80 Quick Installation","text":""},{"location":"guides/installation/#option-1-development-installation-recommended","title":"Option 1: Development Installation (Recommended)","text":"<p>For development, testing, or if you want to modify the code:</p> <pre><code># Clone the repository\ngit clone https://github.com/fasrc/doc-fun.git\ncd doc-fun\n\n# Install in editable mode with development dependencies\npip install -e \".[dev]\"\n\n# Verify installation\ndoc-gen --version\ndoc-gen --help\n</code></pre>"},{"location":"guides/installation/#option-2-production-installation","title":"Option 2: Production Installation","text":"<p>For production use (when available on PyPI):</p> <pre><code># Install from PyPI (future release)\npip install doc-generator\n\n# Verify installation\ndoc-gen --version\n</code></pre>"},{"location":"guides/installation/#environment-setup","title":"\ud83d\udd27 Environment Setup","text":""},{"location":"guides/installation/#1-openai-api-configuration","title":"1. OpenAI API Configuration","text":"<p>Create a <code>.env</code> file in your project directory:</p> <pre><code># Create .env file\ntouch .env\n\n# Add your OpenAI API key\necho \"OPENAI_API_KEY=your-api-key-here\" &gt;&gt; .env\n</code></pre> <p>Getting an OpenAI API Key: 1. Visit OpenAI API Platform 2. Create an account or sign in 3. Navigate to API Keys section 4. Create a new secret key 5. Copy the key to your <code>.env</code> file</p> <p>Important Security Notes: - Never commit <code>.env</code> files to version control - Keep your API key secure and private - Monitor your API usage to avoid unexpected charges</p>"},{"location":"guides/installation/#2-configuration-files","title":"2. Configuration Files","text":"<p>Set up the basic configuration structure:</p> <pre><code># Create configuration directories\nmkdir -p prompts/generator prompts/analysis\nmkdir -p examples output\n\n# Copy default configuration files (if they don't exist)\n# These are included in the repository\n</code></pre> <p>Key Configuration Files: - <code>prompts/generator/default.yaml</code> - Default prompt template - <code>terminology.yaml</code> - HPC modules and terminology - <code>examples/</code> - Few-shot learning examples</p>"},{"location":"guides/installation/#virtual-environment-setup","title":"\ud83d\udc0d Virtual Environment Setup","text":""},{"location":"guides/installation/#using-venv-recommended","title":"Using venv (Recommended)","text":"<pre><code># Create virtual environment\npython -m venv doc-generator-env\n\n# Activate virtual environment\n# On Linux/macOS:\nsource doc-generator-env/bin/activate\n# On Windows:\ndoc-generator-env\\Scripts\\activate\n\n# Install doc-generator\npip install -e .\n\n# Deactivate when done\ndeactivate\n</code></pre>"},{"location":"guides/installation/#using-conda","title":"Using conda","text":"<pre><code># Create conda environment\nconda create -n doc-generator python=3.10\nconda activate doc-generator\n\n# Install doc-generator\npip install -e .\n\n# Deactivate when done\nconda deactivate\n</code></pre>"},{"location":"guides/installation/#verify-installation","title":"\ud83e\uddea Verify Installation","text":""},{"location":"guides/installation/#basic-verification","title":"Basic Verification","text":"<pre><code># Check version\ndoc-gen --version\n\n# List available plugins\ndoc-gen --list-plugins\n\n# View help\ndoc-gen --help\n</code></pre>"},{"location":"guides/installation/#test-generation","title":"Test Generation","text":"<pre><code># Set your OpenAI API key\nexport OPENAI_API_KEY=\"your-api-key-here\"\n\n# Run a simple test\ndoc-gen --topic \"Test Installation\" --runs 1 --output-dir ./test-output\n\n# Check output\nls -la test-output/\n</code></pre>"},{"location":"guides/installation/#run-test-suite","title":"Run Test Suite","text":"<pre><code># Run all tests\npython -m pytest -v\n\n# Expected output: 57 tests should pass\n# ========================= 57 passed in X.XXs =========================\n</code></pre>"},{"location":"guides/installation/#development-setup","title":"\ud83d\udee0\ufe0f Development Setup","text":""},{"location":"guides/installation/#full-development-installation","title":"Full Development Installation","text":"<pre><code># Clone repository\ngit clone https://github.com/fasrc/doc-fun.git\ncd doc-fun\n\n# Install with all development dependencies\npip install -e \".[dev,test]\"\n\n# Install pre-commit hooks (if available)\npre-commit install\n\n# Run development checks\npython -m pytest -v\npython -m black src/ tests/\npython -m flake8 src/ tests/\n</code></pre>"},{"location":"guides/installation/#ide-configuration","title":"IDE Configuration","text":""},{"location":"guides/installation/#vs-code","title":"VS Code","text":"<p>Create <code>.vscode/settings.json</code>:</p> <pre><code>{\n    \"python.defaultInterpreterPath\": \"./doc-generator-env/bin/python\",\n    \"python.testing.pytestEnabled\": true,\n    \"python.testing.pytestArgs\": [\"tests\"],\n    \"python.linting.enabled\": true,\n    \"python.linting.flake8Enabled\": true,\n    \"python.formatting.provider\": \"black\"\n}\n</code></pre>"},{"location":"guides/installation/#pycharm","title":"PyCharm","text":"<ol> <li>Set Python interpreter to your virtual environment</li> <li>Enable pytest as test runner</li> <li>Configure Black as code formatter</li> <li>Enable flake8 for linting</li> </ol>"},{"location":"guides/installation/#troubleshooting","title":"\ud83d\udea8 Troubleshooting","text":""},{"location":"guides/installation/#common-issues","title":"Common Issues","text":""},{"location":"guides/installation/#issue-modulenotfounderror-no-module-named-doc_generator","title":"Issue: <code>ModuleNotFoundError: No module named 'doc_generator'</code>","text":"<p>Solution: <pre><code># Make sure you're in the correct directory\ncd /path/to/doc-fun\n\n# Reinstall in editable mode\npip install -e .\n</code></pre></p>"},{"location":"guides/installation/#issue-openai-api-key-not-found","title":"Issue: <code>OpenAI API key not found</code>","text":"<p>Solution: <pre><code># Check if .env file exists\nls -la .env\n\n# Verify API key is set\ncat .env\n\n# Set environment variable directly\nexport OPENAI_API_KEY=\"your-api-key-here\"\n</code></pre></p>"},{"location":"guides/installation/#issue-importerror-no-module-named-openai","title":"Issue: <code>ImportError: No module named 'openai'</code>","text":"<p>Solution: <pre><code># Check if dependencies are installed\npip list | grep openai\n\n# Reinstall dependencies\npip install -r requirements.txt\n# OR\npip install -e .\n</code></pre></p>"},{"location":"guides/installation/#issue-tests-failing-during-installation","title":"Issue: Tests failing during installation","text":"<p>Solution: <pre><code># Check Python version\npython --version  # Should be 3.8+\n\n# Clean installation\npip uninstall doc-generator\npip cache purge\npip install -e .\n\n# Run tests individually\npython -m pytest tests/test_plugin_interface.py -v\n</code></pre></p>"},{"location":"guides/installation/#getting-help","title":"Getting Help","text":""},{"location":"guides/installation/#check-system-information","title":"Check System Information","text":"<pre><code># Python version\npython --version\n\n# Pip version\npip --version\n\n# Installed packages\npip list\n\n# Doc-generator installation\npip show doc-generator\n</code></pre>"},{"location":"guides/installation/#debugging-steps","title":"Debugging Steps","text":"<ol> <li> <p>Check Installation: <pre><code>python -c \"import doc_generator; print(doc_generator.__version__)\"\n</code></pre></p> </li> <li> <p>Check Plugin Discovery: <pre><code>python -c \"from importlib.metadata import entry_points; print(list(entry_points(group='doc_generator.plugins')))\"\n</code></pre></p> </li> <li> <p>Check Configuration: <pre><code>doc-gen --list-plugins --verbose\n</code></pre></p> </li> </ol>"},{"location":"guides/installation/#support-channels","title":"Support Channels","text":"<ul> <li>GitHub Issues: Report bugs and request features</li> <li>Documentation: Read the guides</li> <li>FASRC Support: Contact FASRC Research Computing</li> </ul>"},{"location":"guides/installation/#updating","title":"\ud83d\udd04 Updating","text":""},{"location":"guides/installation/#update-development-installation","title":"Update Development Installation","text":"<pre><code># Pull latest changes\ngit pull origin main\n\n# Update dependencies\npip install -e \".[dev]\"\n\n# Run tests to verify\npython -m pytest -v\n</code></pre>"},{"location":"guides/installation/#update-production-installation","title":"Update Production Installation","text":"<pre><code># Update from PyPI (when available)\npip install --upgrade doc-generator\n\n# Verify update\ndoc-gen --version\n</code></pre>"},{"location":"guides/installation/#docker-installation-optional","title":"\ud83c\udfd7\ufe0f Docker Installation (Optional)","text":""},{"location":"guides/installation/#using-docker","title":"Using Docker","text":"<pre><code># Dockerfile\nFROM python:3.10-slim\n\nWORKDIR /app\nCOPY . .\n\nRUN pip install -e .\n\nCMD [\"doc-gen\", \"--help\"]\n</code></pre> <pre><code># Build image\ndocker build -t doc-generator .\n\n# Run container\ndocker run -e OPENAI_API_KEY=\"your-key\" doc-generator \\\n  doc-gen --topic \"Docker Test\" --output-dir /app/output\n</code></pre>"},{"location":"guides/installation/#next-steps","title":"\u2705 Next Steps","text":"<p>After successful installation:</p> <ol> <li>\ud83d\udcd6 Read Getting Started Guide - Learn basic usage</li> <li>\ud83e\uddea Run Tests - Understand the test suite</li> <li>\ud83d\udd0c Create Plugins - Extend functionality</li> <li>\ud83d\udee0\ufe0f Configure Templates - Customize prompts and terminology</li> </ol> <p>Installation Complete! \ud83c\udf89</p> <p>Your doc-generator installation is ready. You can now generate AI-powered documentation with intelligent plugin recommendations.</p>"},{"location":"guides/testing/","title":"Testing Guide","text":"<p>This comprehensive guide covers how to run tests, understand test results, write new tests, and maintain test quality for doc-generator.</p>"},{"location":"guides/testing/#running-tests","title":"\ud83e\uddea Running Tests","text":""},{"location":"guides/testing/#quick-test-commands","title":"Quick Test Commands","text":"<pre><code># Run all tests\npython -m pytest\n\n# Run with verbose output\npython -m pytest -v\n\n# Run with short traceback format\npython -m pytest -v --tb=short\n\n# Run tests and show coverage\npython -m pytest --cov=src/doc_generator --cov-report=html\n</code></pre>"},{"location":"guides/testing/#test-categories","title":"Test Categories","text":"<p>The test suite is organized into several categories:</p> <pre><code># Core functionality tests\npython -m pytest tests/test_doc_generator.py -v\n\n# Plugin system tests\npython -m pytest tests/test_plugin_manager.py -v\npython -m pytest tests/test_plugin_interface.py -v\n\n# Integration tests\npython -m pytest tests/test_plugin_integration.py -v\n\n# Run specific test class\npython -m pytest tests/test_plugin_manager.py::TestPluginManager -v\n\n# Run specific test method\npython -m pytest tests/test_plugin_interface.py::TestRecommendationEngineInterface::test_recommendation_engine_is_abstract -v\n</code></pre>"},{"location":"guides/testing/#test-results-understanding","title":"Test Results Understanding","text":"<p>Successful Test Run: <pre><code>============================= test session starts ==============================\nplatform darwin -- Python 3.10.14, pytest-8.4.1, pluggy-1.6.0\ncollecting ... collected 57 items\n\ntests/test_doc_generator.py::TestDocumentationGenerator::test_init_with_defaults PASSED [  1%]\ntests/test_plugin_manager.py::TestPluginManager::test_initialization PASSED [100%]\n\n========================= 57 passed in 0.41s =========================\n</code></pre></p> <p>Test Failure Example: <pre><code>FAILED tests/test_plugin_manager.py::TestPluginManager::test_plugin_discovery_success\n_________________________ TestPluginManager.test_plugin_discovery_success _________________________\n\n    def test_plugin_discovery_success(self, sample_terminology):\n        mock_entry_point = Mock()\n        mock_entry_point.name = \"datasets\"\n&gt;       mock_entry_point.load.return_value = MockDatasetRecommender\nE       NameError: name 'MockDatasetRecommender' is not defined\n\ntests/test_plugin_manager.py:156: NameError\n</code></pre></p>"},{"location":"guides/testing/#test-coverage","title":"\ud83d\udcca Test Coverage","text":""},{"location":"guides/testing/#generate-coverage-reports","title":"Generate Coverage Reports","text":"<pre><code># HTML coverage report\npython -m pytest --cov=src/doc_generator --cov-report=html\n\n# View in browser\nopen htmlcov/index.html\n\n# Terminal coverage report\npython -m pytest --cov=src/doc_generator --cov-report=term-missing\n\n# Coverage with specific threshold\npython -m pytest --cov=src/doc_generator --cov-fail-under=90\n</code></pre>"},{"location":"guides/testing/#current-test-coverage","title":"Current Test Coverage","text":"<p>Test Statistics (as of v1.1.0): - Total Tests: 57 - Test Files: 4 - Coverage: ~95% of core functionality - Plugin Tests: 29 tests covering plugin architecture - Integration Tests: 6 tests covering system integration</p> <p>Coverage Breakdown: <pre><code>Name                                 Stmts   Miss  Cover   Missing\n----------------------------------------------------------------\nsrc/doc_generator/__init__.py           8      0   100%\nsrc/doc_generator/core.py             235     12    95%   45-47, 234-236\nsrc/doc_generator/plugin_manager.py    89      3    97%   67-69\nsrc/doc_generator/plugins/base.py      67      2    97%   89-91\nsrc/doc_generator/plugins/modules.py  156      8    95%   234-241\nsrc/doc_generator/cli.py              198     45    77%   167-189, 234-267\n----------------------------------------------------------------\nTOTAL                                 753     70    91%\n</code></pre></p>"},{"location":"guides/testing/#test-architecture","title":"\ud83c\udfd7\ufe0f Test Architecture","text":""},{"location":"guides/testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 conftest.py                 # Shared fixtures and configuration\n\u251c\u2500\u2500 fixtures/\n\u2502   \u2514\u2500\u2500 mock_plugins.py        # Mock plugin implementations\n\u251c\u2500\u2500 test_doc_generator.py      # Core functionality tests\n\u251c\u2500\u2500 test_plugin_manager.py     # Plugin management tests\n\u251c\u2500\u2500 test_plugin_interface.py   # Plugin interface tests\n\u2514\u2500\u2500 test_plugin_integration.py # Full system integration tests\n</code></pre>"},{"location":"guides/testing/#test-categories-explained","title":"Test Categories Explained","text":""},{"location":"guides/testing/#1-core-functionality-tests-test_doc_generatorpy","title":"1. Core Functionality Tests (<code>test_doc_generator.py</code>)","text":"<pre><code>class TestDocumentationGenerator:\n    \"\"\"Tests for main DocumentationGenerator class\"\"\"\n\nclass TestDocumentAnalyzer:\n    \"\"\"Tests for HTML analysis functionality\"\"\"\n\nclass TestGPTQualityEvaluator:\n    \"\"\"Tests for GPT-based quality assessment\"\"\"\n\nclass TestCodeExampleScanner:\n    \"\"\"Tests for code scanning and analysis\"\"\"\n\nclass TestModuleRecommender:\n    \"\"\"Tests for HPC module recommendation plugin\"\"\"\n</code></pre>"},{"location":"guides/testing/#2-plugin-system-tests-test_plugin_managerpy","title":"2. Plugin System Tests (<code>test_plugin_manager.py</code>)","text":"<pre><code>class TestPluginManager:\n    \"\"\"Tests for plugin discovery, loading, and management\"\"\"\n\n    def test_plugin_discovery_success(self):\n        \"\"\"Test successful plugin discovery via entry points\"\"\"\n\n    def test_plugin_loading_failure(self):\n        \"\"\"Test graceful handling of plugin load failures\"\"\"\n</code></pre>"},{"location":"guides/testing/#3-plugin-interface-tests-test_plugin_interfacepy","title":"3. Plugin Interface Tests (<code>test_plugin_interface.py</code>)","text":"<pre><code>class TestRecommendationEngineInterface:\n    \"\"\"Tests for plugin base class and interface requirements\"\"\"\n\n    def test_recommendation_engine_is_abstract(self):\n        \"\"\"Test that base class cannot be instantiated\"\"\"\n\n    def test_valid_plugin_implementation(self):\n        \"\"\"Test that proper plugins work correctly\"\"\"\n</code></pre>"},{"location":"guides/testing/#4-integration-tests-test_plugin_integrationpy","title":"4. Integration Tests (<code>test_plugin_integration.py</code>)","text":"<pre><code>class TestPluginIntegration:\n    \"\"\"Tests for full system integration with plugins\"\"\"\n\n    def test_multiple_plugins_in_context(self):\n        \"\"\"Test multiple plugins working together\"\"\"\n\n    def test_plugin_failure_doesnt_break_generation(self):\n        \"\"\"Test system resilience to plugin failures\"\"\"\n</code></pre>"},{"location":"guides/testing/#fixtures-and-mocks","title":"Fixtures and Mocks","text":""},{"location":"guides/testing/#key-fixtures-conftestpy","title":"Key Fixtures (<code>conftest.py</code>)","text":"<pre><code>@pytest.fixture\ndef temp_dir():\n    \"\"\"Create temporary directory for test files\"\"\"\n\n@pytest.fixture\ndef sample_terminology():\n    \"\"\"Sample HPC modules and terminology for testing\"\"\"\n\n@pytest.fixture\ndef mock_plugin_discovery():\n    \"\"\"Mock plugin discovery process\"\"\"\n\n@pytest.fixture\ndef mock_openai_client():\n    \"\"\"Mock OpenAI API client\"\"\"\n</code></pre>"},{"location":"guides/testing/#mock-plugins-fixturesmock_pluginspy","title":"Mock Plugins (<code>fixtures/mock_plugins.py</code>)","text":"<pre><code>class MockRecommendationEngine(RecommendationEngine):\n    \"\"\"Base mock plugin for testing\"\"\"\n\nclass MockDatasetRecommender(MockRecommendationEngine):\n    \"\"\"Mock dataset recommender plugin\"\"\"\n\nclass FailingPlugin(MockRecommendationEngine):\n    \"\"\"Plugin that fails for error testing\"\"\"\n</code></pre>"},{"location":"guides/testing/#writing-new-tests","title":"\u270d\ufe0f Writing New Tests","text":""},{"location":"guides/testing/#test-writing-guidelines","title":"Test Writing Guidelines","text":""},{"location":"guides/testing/#1-follow-naming-conventions","title":"1. Follow Naming Conventions","text":"<pre><code># Good test names\ndef test_plugin_loads_successfully_with_valid_config():\ndef test_recommendation_engine_raises_error_with_invalid_input():\ndef test_module_recommender_returns_empty_list_for_unknown_topic():\n\n# Poor test names  \ndef test_plugin():\ndef test_error():\ndef test_modules():\n</code></pre>"},{"location":"guides/testing/#2-use-descriptive-docstrings","title":"2. Use Descriptive Docstrings","text":"<pre><code>def test_plugin_discovery_with_multiple_plugins(self, sample_terminology, mock_plugin_discovery):\n    \"\"\"\n    Test that multiple plugins can be discovered and loaded simultaneously.\n\n    This test verifies:\n    - Multiple entry points are processed correctly\n    - Each plugin gets its own instance\n    - Plugin manager maintains separate references\n    - No interference between plugin loading\n    \"\"\"\n</code></pre>"},{"location":"guides/testing/#3-structure-tests-with-aaa-pattern","title":"3. Structure Tests with AAA Pattern","text":"<pre><code>def test_module_recommender_scores_python_modules_higher_for_python_topics(self, sample_terminology):\n    \"\"\"Test that Python modules get higher relevance scores for Python topics.\"\"\"\n\n    # Arrange\n    recommender = ModuleRecommender(terminology=sample_terminology)\n    python_topic = \"Python Data Analysis with Pandas\"\n\n    # Act\n    recommendations = recommender.get_recommendations(python_topic)\n\n    # Assert\n    assert len(recommendations) &gt; 0\n    top_recommendation = recommendations[0]\n    assert 'python' in top_recommendation['name'].lower()\n    assert top_recommendation['relevance_score'] &gt; 5.0\n</code></pre>"},{"location":"guides/testing/#adding-tests-for-new-features","title":"Adding Tests for New Features","text":""},{"location":"guides/testing/#example-adding-tests-for-a-new-plugin","title":"Example: Adding Tests for a New Plugin","text":"<p>1. Create Mock Plugin</p> <pre><code># In tests/fixtures/mock_plugins.py\nclass MockWorkflowRecommender(MockRecommendationEngine):\n    \"\"\"Mock workflow recommender for testing\"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(name='workflows', **kwargs)\n        self._recommendations = [\n            {\n                \"name\": \"SLURM Array Job Template\",\n                \"type\": \"job_script\",\n                \"relevance_score\": 8.5\n            }\n        ]\n\n    def get_supported_types(self):\n        return [\"workflows\", \"job_scripts\", \"templates\"]\n</code></pre> <p>2. Add Plugin Manager Tests</p> <pre><code># In tests/test_plugin_manager.py\ndef test_workflow_plugin_discovery(self, sample_terminology, mock_plugin_discovery):\n    \"\"\"Test discovery of workflow recommendation plugin.\"\"\"\n    plugins = {\"workflows\": MockWorkflowRecommender}\n\n    with mock_plugin_discovery(plugins):\n        manager = PluginManager(terminology=sample_terminology)\n        manager.load_plugins()\n\n        assert \"workflows\" in manager.engines\n        assert isinstance(manager.engines[\"workflows\"], MockWorkflowRecommender)\n</code></pre> <p>3. Add Integration Tests</p> <pre><code># In tests/test_plugin_integration.py\ndef test_workflow_recommendations_in_context(self, temp_dir, sample_terminology, mock_plugin_discovery):\n    \"\"\"Test that workflow recommendations appear in documentation context.\"\"\"\n    plugins = {\"workflows\": MockWorkflowRecommender}\n\n    with mock_plugin_discovery(plugins):\n        # ... setup generator\n        context = generator._build_terminology_context(\"Parallel Processing\")\n\n        assert \"SLURM Array Job Template\" in context\n        assert \"job_script\" in context\n</code></pre>"},{"location":"guides/testing/#testing-error-conditions","title":"Testing Error Conditions","text":""},{"location":"guides/testing/#test-plugin-failures","title":"Test Plugin Failures","text":"<pre><code>def test_plugin_with_invalid_recommendations_handled_gracefully(self, sample_terminology, mock_plugin_discovery):\n    \"\"\"Test that plugins returning invalid data don't crash the system.\"\"\"\n\n    class BadPlugin(RecommendationEngine):\n        def get_name(self):\n            return \"bad\"\n\n        def get_recommendations(self, topic, context=None):\n            return \"invalid_return_type\"  # Should return list\n\n    plugins = {\"bad\": BadPlugin}\n\n    with mock_plugin_discovery(plugins):\n        manager = PluginManager(terminology=sample_terminology)\n        manager.load_plugins()\n\n        # Should not crash, should handle gracefully\n        results = manager.get_recommendations(\"test topic\")\n        assert isinstance(results, dict)\n</code></pre>"},{"location":"guides/testing/#test-configuration-errors","title":"Test Configuration Errors","text":"<pre><code>def test_documentation_generator_handles_missing_config_files(self, temp_dir):\n    \"\"\"Test graceful handling of missing configuration files.\"\"\"\n\n    # Don't create config files - test with missing files\n    with patch.dict(os.environ, {'OPENAI_API_KEY': 'test-key'}):\n        # Should not crash, should use defaults\n        generator = DocumentationGenerator(\n            prompt_yaml_path=\"nonexistent.yaml\",\n            terminology_path=\"missing.yaml\"\n        )\n\n        assert generator.prompt_config is not None\n        assert generator.terminology is not None\n</code></pre>"},{"location":"guides/testing/#test-utilities-and-helpers","title":"\ud83d\udd27 Test Utilities and Helpers","text":""},{"location":"guides/testing/#custom-assertions","title":"Custom Assertions","text":"<pre><code># In tests/test_helpers.py (create if needed)\ndef assert_valid_html(html_content):\n    \"\"\"Assert that content is valid HTML.\"\"\"\n    from bs4 import BeautifulSoup\n    soup = BeautifulSoup(html_content, 'html.parser')\n    assert soup.find('title') is not None\n    assert soup.find('body') is not None\n\ndef assert_contains_module_recommendations(content):\n    \"\"\"Assert that content contains HPC module recommendations.\"\"\"\n    assert \"module load\" in content\n    assert any(module in content for module in [\"python/\", \"gcc/\", \"cuda/\"])\n\ndef assert_plugin_interface_compliance(plugin_class):\n    \"\"\"Assert that a plugin class properly implements the interface.\"\"\"\n    from doc_generator.plugins.base import RecommendationEngine\n    assert issubclass(plugin_class, RecommendationEngine)\n\n    # Test instantiation\n    plugin = plugin_class()\n    assert hasattr(plugin, 'get_name')\n    assert hasattr(plugin, 'get_recommendations')\n    assert callable(plugin.get_name)\n    assert callable(plugin.get_recommendations)\n</code></pre>"},{"location":"guides/testing/#test-data-factories","title":"Test Data Factories","text":"<pre><code># In tests/factories.py (create if needed)\ndef create_sample_hpc_module(name=\"python/3.12.8-fasrc01\", category=\"programming\"):\n    \"\"\"Factory for creating test HPC module data.\"\"\"\n    return {\n        'name': name,\n        'description': f'Test module {name}',\n        'category': category\n    }\n\ndef create_sample_terminology(num_modules=5):\n    \"\"\"Factory for creating test terminology data.\"\"\"\n    return {\n        'hpc_modules': [\n            create_sample_hpc_module(f\"test-module-{i}/1.0.0\") \n            for i in range(num_modules)\n        ],\n        'cluster_commands': [\n            {'name': 'sbatch', 'description': 'Submit batch job'}\n        ]\n    }\n</code></pre>"},{"location":"guides/testing/#performance-testing","title":"\ud83d\udcc8 Performance Testing","text":""},{"location":"guides/testing/#timing-tests","title":"Timing Tests","text":"<pre><code>import time\n\ndef test_plugin_loading_performance(self, sample_terminology, mock_plugin_discovery):\n    \"\"\"Test that plugin loading completes within reasonable time.\"\"\"\n    plugins = {f\"plugin_{i}\": MockRecommendationEngine for i in range(10)}\n\n    with mock_plugin_discovery(plugins):\n        start_time = time.time()\n\n        manager = PluginManager(terminology=sample_terminology)\n        manager.load_plugins()\n\n        load_time = time.time() - start_time\n\n        assert load_time &lt; 1.0  # Should load 10 plugins in under 1 second\n        assert len(manager.engines) == 10\n</code></pre>"},{"location":"guides/testing/#memory-usage-tests","title":"Memory Usage Tests","text":"<pre><code>import psutil\nimport os\n\ndef test_plugin_memory_usage_reasonable(self, sample_terminology, mock_plugin_discovery):\n    \"\"\"Test that plugin loading doesn't consume excessive memory.\"\"\"\n    process = psutil.Process(os.getpid())\n    initial_memory = process.memory_info().rss\n\n    plugins = {f\"plugin_{i}\": MockRecommendationEngine for i in range(100)}\n\n    with mock_plugin_discovery(plugins):\n        manager = PluginManager(terminology=sample_terminology)\n        manager.load_plugins()\n\n        final_memory = process.memory_info().rss\n        memory_increase = final_memory - initial_memory\n\n        # Should not increase memory by more than 50MB for 100 plugins\n        assert memory_increase &lt; 50 * 1024 * 1024\n</code></pre>"},{"location":"guides/testing/#debugging-test-failures","title":"\ud83d\udea8 Debugging Test Failures","text":""},{"location":"guides/testing/#common-test-failure-patterns","title":"Common Test Failure Patterns","text":""},{"location":"guides/testing/#1-import-errors","title":"1. Import Errors","text":"<pre><code># Error\nModuleNotFoundError: No module named 'doc_generator'\n\n# Solution\ncd /path/to/doc-fun\npip install -e .\npython -m pytest\n</code></pre>"},{"location":"guides/testing/#2-fixture-not-found","title":"2. Fixture Not Found","text":"<pre><code># Error\nfixture 'sample_terminology' not found\n\n# Check conftest.py exists and contains the fixture\ncat tests/conftest.py | grep \"def sample_terminology\"\n</code></pre>"},{"location":"guides/testing/#3-mock-errors","title":"3. Mock Errors","text":"<pre><code># Error\nAttributeError: &lt;module 'doc_generator'&gt; does not have the attribute 'OpenAI'\n\n# Fix patch path\n# Wrong: patch('doc_generator.OpenAI')\n# Right: patch('doc_generator.core.OpenAI')\n</code></pre>"},{"location":"guides/testing/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"guides/testing/#1-isolate-failing-tests","title":"1. Isolate Failing Tests","text":"<pre><code># Run only failing test\npython -m pytest tests/test_plugin_manager.py::TestPluginManager::test_failing_method -v -s\n\n# Run with pdb debugger\npython -m pytest tests/test_plugin_manager.py::TestPluginManager::test_failing_method --pdb\n</code></pre>"},{"location":"guides/testing/#2-add-debug-output","title":"2. Add Debug Output","text":"<pre><code>def test_debug_example(self, sample_terminology):\n    \"\"\"Test with debug output.\"\"\"\n    import pprint\n\n    recommender = ModuleRecommender(terminology=sample_terminology)\n    results = recommender.get_recommendations(\"Python\")\n\n    # Debug output\n    print(\"\\n=== DEBUG OUTPUT ===\")\n    print(f\"Results type: {type(results)}\")\n    print(f\"Results length: {len(results)}\")\n    pprint.pprint(results)\n    print(\"=== END DEBUG ===\\n\")\n\n    assert len(results) &gt; 0\n</code></pre>"},{"location":"guides/testing/#3-use-temporary-debug-tests","title":"3. Use Temporary Debug Tests","text":"<pre><code>def test_debug_plugin_loading(self, sample_terminology, mock_plugin_discovery):\n    \"\"\"Temporary test to debug plugin loading.\"\"\"\n    plugins = {\"test\": MockRecommendationEngine}\n\n    with mock_plugin_discovery(plugins):\n        manager = PluginManager(terminology=sample_terminology)\n\n        print(f\"Before loading: {len(manager.engines)}\")\n        manager.load_plugins()\n        print(f\"After loading: {len(manager.engines)}\")\n        print(f\"Loaded plugins: {list(manager.engines.keys())}\")\n\n        assert \"test\" in manager.engines\n</code></pre>"},{"location":"guides/testing/#test-quality-guidelines","title":"\ud83c\udfaf Test Quality Guidelines","text":""},{"location":"guides/testing/#test-quality-checklist","title":"Test Quality Checklist","text":"<ul> <li> Clear test names describing what is being tested</li> <li> Descriptive docstrings explaining purpose and expectations</li> <li> Single responsibility - each test tests one thing</li> <li> Proper setup/teardown using fixtures</li> <li> No external dependencies - use mocks for APIs, file systems</li> <li> Deterministic - tests produce same results every time</li> <li> Fast execution - tests complete quickly</li> <li> Error condition coverage - test failure scenarios</li> </ul>"},{"location":"guides/testing/#code-coverage-goals","title":"Code Coverage Goals","text":"<ul> <li>Core modules: 95%+ coverage</li> <li>Plugin system: 90%+ coverage  </li> <li>CLI interface: 80%+ coverage</li> <li>Integration tests: Cover major workflows</li> <li>Error handling: Test all exception paths</li> </ul>"},{"location":"guides/testing/#continuous-integration","title":"\ud83d\udd04 Continuous Integration","text":""},{"location":"guides/testing/#github-actions-integration","title":"GitHub Actions Integration","text":"<pre><code># .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.8, 3.9, 3.10, 3.11, 3.12]\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v3\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        pip install -e \".[dev,test]\"\n\n    - name: Run tests\n      run: |\n        python -m pytest -v --cov=src/doc_generator --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n</code></pre>"},{"location":"guides/testing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/psf/black\n    rev: 22.3.0\n    hooks:\n      - id: black\n        language_version: python3\n\n  - repo: https://github.com/pycqa/flake8\n    rev: 4.0.1\n    hooks:\n      - id: flake8\n\n  - repo: local\n    hooks:\n      - id: pytest\n        name: pytest\n        entry: python -m pytest\n        language: python\n        pass_filenames: false\n        always_run: true\n</code></pre>"},{"location":"guides/testing/#next-steps","title":"\u2705 Next Steps","text":"<p>After mastering testing:</p> <ol> <li>\ud83d\udd0c Create Plugins Guide - Build your own plugins</li> <li>\ud83d\udcda Advanced Configuration - Customize the system</li> <li>\ud83e\udd1d Contributing Guide - Contribute to the project</li> </ol>"},{"location":"guides/testing/#testing-mastery","title":"\ud83c\udf89 Testing Mastery","text":"<p>You now understand: - How to run and interpret tests - Test architecture and organization - Writing effective new tests - Debugging test failures - Maintaining test quality - Performance and integration testing</p> <p>Keep testing, keep improving! \ud83e\uddea\u2728</p>"}]}